#!/usr/bin/env python
# coding: utf-8

import os
import sys
import csv
import json
import hashlib
import optparse
import collections
path = os.path.dirname(os.path.abspath(__file__))
libpath = os.path.join(path, '../lib/')
sys.path.insert(0, libpath)
import grouping


def parse_dataset_split_by_fingerprints(cert_path, dataset):
    pre = {}
    data = {}
    # Load fingerprints and classes from the dataset
    with open(dataset) as csv_file:
        csv_dict = csv.DictReader(csv_file, delimiter='\t')
        for elem in csv_dict:
            eid = '{}:{}'.format(elem['sha2'], elem['conn_uid'])
            fgpt = elem['c_tls_fingerprint_label']
            avc = elem['avclass_family']
            data.update({eid: {'fgpt': fgpt, 'avclass': avc}})
    # Load groups by server certificate
    with open(cert_path) as pf:
        for line in pf:
            pline = line.strip().split(',')
            cid = pline[0]
            label = pline[1]
            fgpt = data[cid]['fgpt']
            if label in pre:
                if fgpt in pre[label]:
                    pre[label][fgpt].append(cid)
                else:
                    pre[label].update({fgpt: [cid]})
            else:
                pre.update({label: {fgpt: [cid]}})
    return (pre, data)

#def output_as_json(clusters, classes):
#    res = []
#    for label, cids in sorted(clusters.items()):
#        idclasses = collections.Counter(classes[i] for i in cids).most_common()
#        current = {
#            'label': int(label),
#            'ids': cids,
#            'avclass': idclasses,
#            'size': len(cids),
#        }
#        res.append(current)
#    return res

def main(options, args):
    # Parse original dataset and split CERT groups by fingerprint
    pre, data = parse_dataset_split_by_fingerprints(options.groups, args[0])
    if options.debug:
        print('Groups by CERT: {}.'.format(len(pre)))
        new_groups = 0
        for label in pre:
            print('Group {}'.format(label))
            print('TLS FINGERPRINTS: {}.'.format(pre[label].keys()))
            new_groups += len(pre[label].keys())
        print('New groups: {}.'.format(new_groups))

    output_file = 'tls_clustering_grouping_cfp.tsv'
    output_json = 'tls_clustering_grouping_cfp.json'

    new_label = 0
    labels = []
    with open(output_file, 'w') as of:
        classes = {}
        clusters = collections.defaultdict(list)
        # Split clusters by client fingerprints
        for c, fgpts in pre.items():
            for fgpt, ids in fgpts.items():
                clusters[new_label] = ids
                for id in ids:
                    print('{},{},{}'.format(id, new_label, fgpt), file=of)
                    labels.append(new_label)
                    classes[id] = data[id]['avclass']
                new_label += 1

    with open(output_json, 'w') as oj:
        json_out = grouping.output_as_json(clusters, classes)
        json.dump(json_out, oj)

    if options.debug:
        print('Groups in the most common(20) list:')
        for label, total in collections.Counter(labels).most_common(20):
            print('\t{}:\t{}'.format(label, total))

    if options.debug:
        print('Grouping by TLS fingerprint, done.')


if __name__ == '__main__':
    parser = optparse.OptionParser(
            usage="Usage: %prog [options] dataset_filename",
            version="%prog 1.0")
    parser.add_option(
            '-g', '--groups', action='store', dest='groups',
            help='Path to the file containing the groups by CERT')
    parser.add_option(
            '-D', '--debug', action='store_true', dest='debug',
            help='Print debug messages',
            default=False)

    options, args = parser.parse_args()

    if len(args) != 1 or not os.path.isfile(args[0]):
        parser.error("Dataset not found. Aborting...")
    if not os.path.isfile(options.groups):
        parser.error("File with groups by CERT not found. Aborting...")

    main(options, args)
