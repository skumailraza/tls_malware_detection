#!/usr/bin/env python
# coding: utf-8

import os
import sys
import csv
import json
import hashlib
import optparse
import collections

def parse_groups(g_path):
    groups = collections.defaultdict(set)
    cids = set()
    with open(g_path) as gf:
        for line in gf:
            pline = line.strip().split(',')
            cid = pline[0]
            label = pline[1]
            cids.add(cid)
            groups[label].add(cid)
    return (groups, cids)

def parse_dataset(ds_path, cids):
    data = {}
    with open(ds_path) as csv_file:
        csv_dict = csv.DictReader(csv_file, delimiter='\t')
        for elem in csv_dict:
            # Take pre-clustered connections only
            eid = '{}:{}'.format(elem['sha2'], elem['conn_uid'])
            if eid in cids:
                data.update({eid: {'enc_data_size': int(elem['enc_data_size']),
                    'avclass_family': elem['avclass_family']
                    }})
    return data

def empty_content(data):
    # Return True if all contents are empty
    # TODO change all empty for a ratio
    empty = True
    for id in data:
        empty &= data[id]['enc_data_size'] == 0
    return empty

def merge_clusters(merge_these, groups):
    for c, g_list in merge_these.items():
        ids = []
        last_g = ''
        for g in g_list:
            ids.extend(groups.pop(g))
            last_g += '{}_'.format(g)
        groups[last_g] = ids
    return groups

def output_as_json(clusters, classes):
    res = []
    for label, cids in sorted(clusters.items()):
        idclasses = collections.Counter(classes[i] for i in cids).most_common()
        current = {
            'label': int(label),
            'ids': cids,
            'avclass': idclasses,
            'size': len(cids),
        }
        res.append(current)
    return res

def main(options, args):
    # Parse groups by TLS FINGERPRINT dataset and original dataset
    (groups, gids) = parse_groups(options.groups)
    (clusters, cids) = parse_groups(options.clusters)
    data = parse_dataset(args[0], cids)

    # Searching for groups with empty content to skip
    omit = set()
    for g, gids in groups.items():
        empty = empty_content({id:data[id] for id in gids})
        if empty: omit.add(g)

    if options.debug:
        print('Pre-processing {} vectors.'.format(len(data)))

    merge_these = collections.defaultdict(list)
    for c, cids in clusters.items():
        for g in [x for x in groups if x not in omit]:
            if cids.issuperset(groups[g]):
                merge_these[c].append(g)
                omit.add(g)
                if options.debug:
                    print('MERGE_THESE: {}'.format(merge_these))

    c_merged = merge_clusters(merge_these, groups)

    output_file = 'tls_all_clustering_grouping_pay.tsv'
    output_json = 'tls_all_clustering_grouping_pay.json'
    if options.output:
        output_file = '{}.tsv'.format(options.output)
        output_json = '{}.json'.format(options.output)

    labels = []
    with open(output_file, 'w') as of:
        classes = {}
        clusters = collections.defaultdict(list)
        for new_label, (label, ids) in enumerate(c_merged.items()):
            clusters[new_label] = [id for id in sorted(ids)]
            for id in ids:
                print('{},{},{}'.format(id, new_label, label), file=of)
                labels.append(new_label)
                classes[id] = data[id]['avclass_family']

    with open(output_json, 'w') as oj:
        json_out = output_as_json(clusters, classes)
        json.dump(json_out, oj)

    if options.debug:
        print('Clusters in the most common(20) list:')
        for label, total in collections.Counter(labels).most_common(20):
            print('\t{}:\t{}'.format(label, total))

    if options.debug:
        print('Grouping by content, done.')


if __name__ == '__main__':
    parser = optparse.OptionParser(
            usage="Usage: %prog [options] dataset_filename",
            version="%prog 1.0")
    parser.add_option(
            '-g', '--groups', action='store', dest='groups',
            help='Path to file containing the groups by TLS FINGERPRINT')
    parser.add_option(
            '-c', '--clusters', action='store', dest='clusters',
            help='Path to file with the clusters')
    parser.add_option(
            '-o', '--output', action='store', dest='output',
            help='Name for the output file with the results')
    parser.add_option(
            '-D', '--debug', action='store_true', dest='debug',
            help='Print debug messages', default=False)

    options, args = parser.parse_args()

    if len(args) != 1 or not os.path.isfile(args[0]):
        parser.error("Dataset not found. Aborting...")
    if not os.path.isfile(options.groups):
        parser.error("Groups file not found. Aborting...")
    if not os.path.isfile(options.clusters):
        parser.error("Clusters file not found. Aborting...")

    main(options, args)
