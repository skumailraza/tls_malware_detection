#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import os
import json
import argparse
import hashlib

FPRINTS_DB_FILE = '/home/platon/ssl-versions/fingerprinting/data/tls_fprints.db'

class DBFileNotFound(Exception):
    pass

def pprint_dict(dic):
    '''Pretty prints a dictionary'''
    import pprint
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(dic)

class TLSFingerprintDB:
    '''Class to load and manage our TLS fingerprint DB '''


    def __init__(self, fname=FPRINTS_DB_FILE):
        self.db_by_fprint = {}
        self.db_raw = []

        if not os.path.isfile(fname):
            raise DBFileNotFound('File does not exist: {} \n'.format(fname))

        with open(fname, 'r') as fr:
            for pos, line in enumerate(fr):
                self.db_raw.append(json.loads(line.strip('\n')))

        for entry in self.db_raw:
            fprint = entry['fprint']
            app_name = entry['desc'].split(';')[0]
            try:
                self.db_by_fprint[fprint]['descs'].add(entry['desc'])
                self.db_by_fprint[fprint]['app_names'].add(app_name)
                self.db_by_fprint[fprint]['types'].add(entry['app_type'])
                self.db_by_fprint[fprint]['entries'].append(entry)
            except KeyError:
                self.db_by_fprint[fprint] = {'descs': set([entry['desc']]),
                                             'app_names': set([app_name]),
                                             'types': set([entry['app_type']]),
                                             'entries': [entry]}
        self._handle_collisions()


    def _handle_collisions(self):
        '''This method will try to solve collisions among TLS fingerprints'''
        clean_db_fp = {}
        libraries = set(['library', 'tor'])
        for fp, info in self.db_by_fprint.items():
         lib_types = libraries.intersection(info['types'])
         if len(info['descs']) == 1:
              # No collision, add it and continue
              clean_db_fp[fp] = {'desc': list(info['descs'])[0],
                                 'type': list(info['types'])[0]}
         elif len(info['descs']) > 1 and\
              len(info['app_names']) == 1 and\
              len(info['types']) == 1:
             # Many versions for the same application;
             # We do not consider it a collision, we merge descriptions
             app_vers = set([])
             os_vers = set([])
             oses = set([])
             for desc in info['descs']:
               app_name, app_ver, os, os_ver, arch, comments = desc.split(';')
               if app_ver:
                   app_vers.add(app_ver)
               if os and os_ver:
                   if os == 'macos':
                     os_vers.add(os_ver)
                   elif os == 'windows':
                     os_vers.add('win {}'.format(os_ver))
                   else:
                     os_vers.add('{} {}'.format(os, os_ver))
                   oses.add(os)
               elif os:
                   oses.add(os)
             clean_db_fp[fp] = { 'desc': '{};{};{};{};;'.\
                                          format(app_name,
                                                 ','.join(sorted(app_vers)),
                                                 ','.join(sorted(oses)),
                                                 ','.join(sorted(os_vers))),
                                 'type': list(info['types'])[0]}
         elif len(info['app_names']) > 1 and lib_types:
             # This is a collision that we can resolve it; We use the library
             lib_names = set([])
             lib_oses = set([])
             lib_vers = set([])
             lib_os_vers = set([])
             for en in info['entries']:
                 if en['app_type'] in libraries:
                     app_name, app_ver, os, os_ver, arch, com = en['desc'].\
                                                                split(';')
                     lib_names.add(app_name)
                     if app_ver:
                         lib_vers.add(app_ver)
                     if os and os_ver:
                         if os == 'macos':
                           lib_os_vers.add(os_ver)
                         elif os == 'windows':
                           lib_os_vers.add('win {}'.format(os_ver))
                         else:
                           lib_os_vers.add('{} {}'.format(os, os_ver))
                           oses.add(os)
                     elif os:
                         lib_oses.add(os)
             #
             if len(lib_names) > 1:
                 raise "Found two different libraries with the "\
                       "same fprint: {}".format(lib_names)
             clean_db_fp[fp] = { 'desc': '{};{};{};{};;library_selection'.\
                                          format(list(lib_names)[0],
                                                 ','.join(sorted(lib_vers)),
                                                 ','.join(sorted(lib_oses)),
                                                 ','.join(sorted(lib_os_vers))),
                                 'type': 'library'}
         else:
             # We have a collission among applications that we cannot ressolve;
             # Select the first one and put a warning on the description
             app_name, app_ver, os, os_ver, arch, com =\
                     info['entries'][0]['desc'].split(';')
             clean_db_fp[fp] = {'desc': '{}_random_app_selection'.\
                                        format(info['entries'][0]['desc']),
                                'type': info['entries'][0]['app_type']}
        # Store the new fprint dictionary
        self.db_by_fprint = clean_db_fp


    def get_raw_entries(self):
        '''Returns the raw entries as where read from the file '''
        return self.db_raw


    def get_contents(self, fprint_fmt='full', unique=True):
        '''Returns the loaded TLS fingeprint DB'''
        supported_fmt = ['full', 'ciphers', 'ciphers_exts', 'no_extensions']
        if fprint_fmt not in supported_fmt:
            return None
        if fprint_fmt == 'full':
            if unique:
                uniq_fprints = {}
                for fp, contents in self.db_by_fprint.items():
                    if 'random_app_selection' in contents['desc']:
                        continue
                    fp_md5 = hashlib.md5(fp).hexdigest()
                    uniq_fprints[fp_md5] = contents
                return uniq_fprints
            return self.db_by_fprint
        return None
        # for fp, contents in self.db_by_fprint.items():
        #     # fp_md5 = hashlib.md5(fp).hexdigest()
        #     fp_fields = fp.split(';')
        #     if fprint_fmt == "ciphers":
        #         new_fp = fp_fields[0]
        #     elif fprint_fmt == "ciphers_exts":
        #         new_fp = ';'.join(fp_fields[:2])
        #     elif fprint_fmt == "no_extensions":
        #         new_fp = '{};{};{}'.\
        #                  format(fp_fields[0], fp_fields[2], fp_fields[3])
        #     try:
        #         new_fprints[new_fp]['names'].add(contents['desc'])
        #         new_fprints[new_fp]['types'].add(contents['type'])
        #         new_fprints[new_fp]['full_fprints'].add(fp)
        #     except KeyError:
        #         new_fprints[new_fp] = {'names': set([contents['desc']]),
        #                                'types': set([contents['type']]),
        #                                'full_fprints': set([fp])}
        # return new_fprints

    def resolve_collision(self, descs):
        ''' '''
        res_desc = '-'
        for desc, dtype in descs.items():
            # If any of the descriptions correspond to a library select it;
            # It (hopefully) means that the other applications use this library
            # for their TLS connections
            if dtype == 'library':
                return desc
            # Similar intuition with above
            # We actually see only malware that collide with Tor fingerprints
            # These malware families use(d) Tor.
            if desc == 'tor':
                return desc
        return res_desc

    def check_collisions(self, fprint_format="full"):
        '''Checks for collisions in the DB. Multiple TLS fingerprints with the
        same TLS fingerprint.
        It can perform the collision checks by:
           - application: Check for distinct applications with the same fprint.
                      Application name is extracted by the description.
                      Default option.
           - description: Check for distinct descriptions with the same fprint.
                      Expect two find many of those due to many application
                      that have the same fingerprint among different versions
                      (e.g., Chrome 24.1 and 25.1)
        It can use as fingeprint:
           - full: Full fingerprint: ciphers;extensions;ec;ec_point_formats
                   Default option
           - ciphers: Uses only the ciphers as fingerprint
           - extensions: Uses only the extensions as fingerprint
           - ciphers_extensions: Uses: ciphers;extensions
        '''
        fprints = {}
        for entry in self.db_raw:
            # Get fprint based on the requested format
            fp_fields = entry['fprint'].split(';')
            if fprint_format == "full":
                fp = entry['fprint_md5']
            elif fprint_format == "ciphers":
                fp = fp_fields[0]
            elif fprint_format == "extensions":
                fp = fp_fields[1]
            elif fprint_format == "ciphers_extensions":
                fp = ';'.join(fp_fields[:2])
            # See how we check for collisions
            fp_desc = entry['desc'].strip('"').split(';')[0].lower()
            fp_type = entry['app_type']
            try:
                fprints[fp][fp_desc] = fp_type
            except KeyError:
                fprints[fp] = {fp_desc: fp_type}

        fprints_sorted = sorted(fprints,\
                                key=lambda k: len(fprints[k].keys()),\
                                reverse=True)
        collisions = list(filter(lambda x: len(fprints[x]) >1, fprints_sorted))
        for fp in collisions:
            resolv_desc = self.resolve_collision(fprints[fp])
            sys.stdout.write('{}\t{}\t{}\t{}\n'.\
                       format(fp, len(fprints[fp]), resolv_desc,
                              ';'.join(fprints[fp])))
        sys.stderr.write('[+] Found {} TLS fingerpints that are shared'
                         ' among two or more distinct applications.\n'.\
                         format(len(collisions)))

    def pprint_db(self, by='app_name'):
        '''Prints the DB contents for each application type. '''
        fprints = {}
        for entry in self.db_raw:
            # Get fprint based on the requested format
            fp_fields = entry['fprint'].split(';')
            if by == 'app_name':
                app_name = entry['desc'].strip('"').split(';')[0].lower()
            else:
                app_name = entry['desc'].strip('"').lower()

            app_type = entry['app_type'] if entry['app_type'] else 'UNKNOWN'

            try:
                fprints[app_type].add(app_name)
            except KeyError:
                fprints[app_type] = set([app_name])

        for app_type, apps in fprints.items():
            sys.stdout.write('\n### ' + app_type.title() + ' ###\n')
            for app in apps:
                sys.stdout.write('\t {}\n'.format(app.title()))

    def dump_fprints(self):
        '''Dumps the TLS fingerpints and their descriptions '''
        fprints = {}
        for entry in self.db_raw:
            try:
                fprints[entry['fprint_md5']].add(entry['desc'])
            except KeyError:
                fprints[entry['fprint_md5']] = set([entry['desc']])

        for fprint, descs in fprints.items():
            sys.stdout.write('{}\t{}\n'.format(fprint, '|'.join(descs)))

    @staticmethod
    def compare_db_entries(old_fprints, new_fprints):
        '''Compares the old fingerprint DB provided with the current one and
        dumps all new entries'''
        old_keys = set(old_fprints.keys())
        new_keys = set(new_fprints.keys())
        diff_keys = new_keys.difference(old_keys)
        for fp in diff_keys:
            sys.stdout.write('{}\t{}\n'.\
                             format(hashlib.md5(fp).hexdigest(),
                                    '|'.join(new_fprints[fp]['names'])))


def main(args):
    """ """
    fprint_db = TLSFingerprintDB(args.db)
    fprints = fprint_db.get_contents()
    if args.col:
        fprint_db.check_collisions(fprint_format=args.col)
    if args.pprint:
        fprint_db.pprint_db(by=args.pprint)
    if args.fprints:
        fprint_db.dump_fprints()
    if args.compare_db:
        old_fprint_db = TLSFingerprintDB(args.compare_db)
        old_fprints = old_fprint_db.get_contents()
        fprint_db.compare_db_entries(old_fprints, fprints)


def validate_arguments(args):
    '''Validates user arguments '''
    if not os.path.isfile(args.db):
        sys.stderr.write('File does not exist: {} \n'.format(args.db))
        exit(1)
    if args.pprint and args.col:
        sys.stderr.write('Cannot use both -col and -pprint parameters.\n')
        exit(1)
    if args.compare_db and not os.path.isfile(args.compare_db):
        sys.stderr.write('File does not exist: {} \n'.format(args.compare_db))
        exit(1)


if __name__ == '__main__':
    argparser = argparse.ArgumentParser(prog='db_fprints',
        description='''Loads a TLS fingeprint DB and  ''')
    argparser.add_argument('-db',
        help='File with the TLS fingerprint database.',
        required=True)
    argparser.add_argument('-col',
        help='Check for collisions in the DB. You can Choose the fingerprint'\
             ' format to use for the collision check. Recommended: full',
        choices=['full', 'ciphers', 'extensions', 'ciphers_extensions'])
    argparser.add_argument('-pprint',
        help='Prints the fingerprint names grouped by application types.'\
             'It can print the full descriptions or group by application '\
             'names. E.g. Chrome 24 and Chrome 25 becomes Chrome',
        choices=['app_name', 'desc'])
    argparser.add_argument('-fprints',
        help='Dumps the distinct fprints in the DB.',
        action='store_true')
    argparser.add_argument('-compare_db',
        help='File with an older version of the TLS fingerprint DB. It will'
        ' dump all fprints that are in the newer version but not in this one.')
    args = argparser.parse_args()
    validate_arguments(args)
    main(args)



