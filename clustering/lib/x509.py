from datetime import datetime as dt
import string
import sys
import OpenSSL 
import shutil
import requests
import hashlib
import subprocess
import M2Crypto
from dateutil.parser import parse

#Object Identifiers that are used from various CAs to mark a certificate
#as an EV certificate (Extended Validation)
EV_OIDS = [
         "1.3.6.1.4.1.34697.2.1",           # AffirmTrust
         "1.3.6.1.4.1.34697.2.2",           # AffirmTrust
         "1.3.6.1.4.1.34697.2.3",           # AffirmTrust
         "1.3.6.1.4.1.34697.2.4",           # AffirmTrust
         "1.2.40.0.17.1.22",                # A-Trust
         "2.16.578.1.26.1.3.3",             # Buypass
         "1.3.6.1.4.1.17326.10.14.2.1.2",   # Camerfirma
         "1.3.6.1.4.1.17326.10.8.12.1.2",   # Camerfirma
         "1.3.6.1.4.1.6449.1.2.1.5.1",      # Comodo
         "2.16.840.1.114412.2.1",           # DigiCert
         "2.16.840.1.114412.1.3.0.2",       # DigiCert
         "2.16.528.1.1001.1.1.1.12.6.1.1.1",# DigiNotar
         "2.16.792.3.0.4.1.1.4",            # E-Tungra
         "2.16.840.1.114028.10.1.2",        # Entrust
         "0.4.0.2042.1.4",                  # ETSI
         "0.4.0.2042.1.5",                  # ETSI
         "1.3.6.1.4.1.13177.10.1.3.10",     # Firmaprofesional
         "1.3.6.1.4.1.14370.1.6",           # GeoTrust
         "1.3.6.1.4.1.4146.1.1",            # GlobalSign
         "2.16.840.1.114413.1.7.23.3",      # Go Daddy
         "1.3.6.1.4.1.14777.6.1.1",         # Izenpe
         "2.16.792.1.2.1.1.5.7.1.9",        # Kamu Sertifikasyon Merkezi
         "1.3.6.1.4.1.22234.2.5.2.3.1",     # Keynectis
         "1.3.6.1.4.1.782.1.2.1.8.1",       # Network Solutions
         "1.3.6.1.4.1.8024.0.2.100.1.2",    # QuoVadis
         "1.2.392.200091.100.721.1",        # SECOM Trust Systems
         "2.16.840.1.114414.1.7.23.3",      # Starfield Technologies
         "1.3.6.1.4.1.23223.2",             # StartCom CA
         "1.3.6.1.4.1.23223.1.1.1",         # StartCom CA
         "2.16.756.1.83.21.0",              # Swisscom
         "2.16.756.1.89.1.2.1.1",           # SwissSign
         "2.16.840.1.113733.1.7.48.1",      # Thawte
         "2.16.840.1.114404.1.1.2.4.1",     # TrustWave
         "2.16.840.1.113733.1.7.23.6",      # VeriSign
         "1.3.6.1.4.1.6334.1.100.1",        # Verizon
         "2.16.840.1.114171.500.9",         # Wells Fargo
         "1.3.6.1.4.1.36305.2"              # WoSign
        ]


def md5_data(data):
    '''Calculates the MD5 hash of the data provided
       Args:
         -Data[string|list]
       Returns:
         -Returns the calculated hash
    '''
    m = hashlib.md5()
    if isinstance(data, list):
        m.update(''.join(data))
    else:
        m.update(data)
    data_hash = m.hexdigest()
    return data_hash


def extract_X509_signature_algorithm(cert):
    '''Extracts the signature algorithm from a M2Crypto X509 object'''
    sign_alg = None
    for line in cert.as_text().split('\n'):
        if 'Signature Algorithm' in line:
            sign_alg = line.split('Signature Algorithm:')[1].strip()
            break
    return sign_alg


def is_cert_expired(cert):
    '''Checks if X509 certificate is expired '''
    not_after = str(cert.get_not_after())
    if not_after == 'Bad time value':
        return None
    not_after_dt = dt.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
    now = dt.now()
    if now > not_after_dt:
        return True
    else:
        return False


def extract_cert_extensions(cert):
    '''Extracts extensions of interest from an M2Crypto X509 object'''
    exts = {
            'ev_flag': False,
            'key_usage': None,
            'ext_key_usage': None,
            'crl_uri': None,
            'ocsp_uri': None,
            'ca_iss_uri': None,
            'alt_domains': [],
            'auth_key_id': None,
            'subj_key_id': None,
            'ext_san_num': None,
            'num_ext': cert.get_ext_count(),
            'ext_ca': bool(cert.check_ca())}

    # Extract subject alternative names
    for index in range(cert.get_ext_count()):
      #Get extension 
      extension = cert.get_ext_at(index) 
      #Get extension name 
      ext_name = str(extension.get_name()).strip() 
      try:
          ext_value = extension.get_value()
      except (M2Crypto.BIO.BIOError, TypeError), e:
          # Weir error - Seems that library cannot parse the 
          # S/MIME Capabilities certificate extension
          ext_value = None
      if ext_name in EV_OIDS:
          exts['ev_flag'] = True
      if ext_name == 'keyUsage':
        exts['key_usage'] = ext_value
      elif ext_name == 'extendedKeyUsage':
        exts['ext_key_usage'] = ext_value
      elif ext_name == 'crlDistributionPoints':
        if "URI" in ext_value:
          crl_line = ext_value
          #print crl_line
          if crl_line.count('Full Name') > 1:
            #Multiple entries in this extension
            entries = crl_line.split("\n")
            for pos,en in enumerate(entries):
              if "Full Name:" in en \
                and "URI" in entries[pos+1]\
                and "crl" in entries[pos+1]:
                exts['crl_uri'] = entries[pos+1].\
                                  split('URI:')[1].\
                                  strip().\
                                  lower()
          else:
            if "Full Name:" in crl_line:
              exts['crl_uri'] = crl_line.\
                                split('Full Name:')[1].\
                                split('URI:')[1].\
                                strip().\
                                lower()
            elif "CRL Issuer:" in crl_line:
              exts['crl_uri'] = crl_line.\
                                split('CRL Issuer:')[1].\
                                split('URI:')[1].\
                                strip().\
                                lower()
      elif ext_name == 'authorityInfoAccess':
        ext_cont = ext_value
        if "OCSP" in ext_cont:
          exts['ocsp_uri'] = ext_cont.\
                             split("OCSP - URI:")[1].\
                             split('\n')[0].\
                             strip().\
                             lower()
        if "CA Issuers" in ext_cont:
          if "CA Issuers - URI:" in ext_cont:
            exts['ca_iss_uri'] = ext_cont.\
                                 split("CA Issuers - URI:")[1].\
                                 split('\n')[0].\
                                 strip().\
                                 lower()
      #Check for SubjectAltName extension
      elif ext_name == 'subjectAltName':
        #Extract all domains icnluded in the extension
        alt_names = ext_value.strip('\,').split(',')
        for name in alt_names:
          clean_name = name.strip()
          if "DNS" in clean_name:
            domain = clean_name.split(':')[1].strip()
            exts['alt_domains'].append(domain.rstrip('.').lower())
      elif ext_name == 'authorityKeyIdentifier':
        auth_attrs = ext_value.split('\n')
        if auth_attrs:
          for attr in auth_attrs:
            if "keyid" in attr:
              exts['auth_key_id'] = attr.split('keyid:')[1].\
                                    replace(":","").lower()
      elif ext_name == 'subjectKeyIdentifier':
        exts['subj_key_id'] = ext_value.replace(":","").lower()
    
    #Update alternative names count (if any)
    if exts['alt_domains']:
        exts['ext_san_num'] = len(exts['alt_domains'])

    return exts


def printable(str):
    '''Cleans a string from non printable characters'''
    return filter(lambda x: x in string.printable, str).strip()


def extract_cert_fields(cert, cert_f, ctype='s'):
    '''Extracts all necessary fields from the M2Crypto.X509 object.'''

    # Generate PEM and DER hash for cert
    pem_hash = md5_data(cert.as_pem())
    der_hash = md5_data(cert.as_der())
    # Extract Public Key
    try:
        pub_key = cert.get_pubkey().as_pem(cipher=None)
    except M2Crypto.BIO.BIOError:
        # error_msg = 'File:{}, cert_der:{} : M2Crypto cannot extract pKey.'.\
        #             format(finfo['md5'], der_hash)
        error_msg = 'File:{}, cert_der:{} : M2Crypto cannot extract pKey.'.\
                    format(cert_f, der_hash)
        
        pub_key = None

    # Extract cert signature algorith
    sign_alg = extract_X509_signature_algorithm(cert)

    #
    # Extract cert extensions
    #
    exts = extract_cert_extensions(cert)

    # Get Publisher and Issuer
    subj = cert.get_subject()
    substr = subj.as_text()
    iss = cert.get_issuer()
    isstr = iss.as_text()
    cert_info = {
        '{}_leaf_cert_subject'.format(ctype): printable(substr),
        "{}_leaf_cert_subj_cn".format(ctype): printable(subj.CN) if\
                subj.get_entries_by_nid(subj.nid['CN']) else '-',
        "{}_leaf_cert_subj_o".format(ctype): printable(subj.O) if\
                subj.get_entries_by_nid(subj.nid['O']) else '-',
        "{}_leaf_cert_subj_ou".format(ctype): printable(subj.OU) if\
                subj.get_entries_by_nid(subj.nid['OU']) else '-',
        "{}_leaf_cert_subj_c".format(ctype): printable(subj.C) if\
                subj.get_entries_by_nid(subj.nid['C']) else '-',
        "{}_leaf_cert_subj_st".format(ctype): printable(subj.ST) if\
                subj.get_entries_by_nid(subj.nid['ST']) else '-',
        "{}_leaf_cert_subj_l".format(ctype): printable(subj.L) if\
                subj.get_entries_by_nid(subj.nid['L']) else '-',
        "{}_leaf_cert_subj_email".format(ctype): printable(subj.Email) if\
                subj.get_entries_by_nid(subj.nid['Email']) else '-',
        '{}_leaf_cert_issuer'.format(ctype): printable(isstr),
        "{}_leaf_cert_iss_cn".format(ctype): printable(iss.CN) if\
                iss.get_entries_by_nid(subj.nid['CN']) else '-',
        "{}_leaf_cert_iss_o".format(ctype): printable(iss.O) if\
                iss.get_entries_by_nid(subj.nid['O']) else '-',
        "{}_leaf_cert_iss_ou".format(ctype): printable(iss.OU) if\
                iss.get_entries_by_nid(subj.nid['OU']) else '-',
        "{}_leaf_cert_iss_c".format(ctype): printable(iss.C) if\
                iss.get_entries_by_nid(subj.nid['C']) else '-',
        "{}_leaf_cert_iss_st".format(ctype): printable(iss.ST) if\
                iss.get_entries_by_nid(subj.nid['ST']) else '-',
        "{}_leaf_cert_iss_l".format(ctype): printable(iss.L) if\
                iss.get_entries_by_nid(subj.nid['L']) else '-',
        "{}_leaf_cert_iss_email".format(ctype): printable(iss.Email) if\
                iss.get_entries_by_nid(subj.nid['Email']) else '-',
        # 'not_before': str(cert.get_not_before()),
        # 'not_after': str(cert.get_not_after()),
        # 'serial': '%032x' % cert.get_serial_number(),
        '{}_leaf_cert_version'.format(ctype): cert.get_version(),
        '{}_leaf_cert_pubkey_hash'.format(ctype):\
                              md5_data(pub_key) if pub_key else pub_key,
        '{}_leaf_cert_pubkey_size'.format(ctype): cert.get_pubkey().size(),
        '{}_leaf_cert_sign_alg'.format(ctype): sign_alg,
        # 'expired': is_cert_expired(cert),
        # 'pem_hash': pem_hash,
        '{}_leaf_cert_der_hash'.format(ctype): der_hash,
        '{}_leaf_cert_ext_num'.format(ctype): len(exts.keys())}

    # Add extensions results to dict
    # cert_info.update(exts)
    return cert_info


def sort_cert_chain(leaf_cert, cert_objs):
    ''' '''
    ord_chain = [leaf_cert]
    while True:
        start_len = len(ord_chain)
        last_cert_subj = list(ord_chain)[-1].get_subject().as_text()
        last_cert_iss = list(ord_chain)[-1].get_issuer().as_text()
        for cert in cert_objs:
            if last_cert_iss == cert.get_subject().as_text() and\
              cert not in ord_chain:
                ord_chain.append(cert)
                break
        if start_len == len(ord_chain):
            break
    # debug_sort_chain(leaf_cert, cert_objs, ord_chain, ch_type)
    return ord_chain


def extract_chains_and_cert_fields(cert_objs, auth, finfo, args, tmp_dir):
    '''Extracts the chain and the certificate fields of all certs.
    if not fullinfo parameter the chain returns only the leaf certificate'''
    cert_chains = {'cs': [], 'ts': []}
    cert_errors = {}

    #
    # Code Signing Certificate chain
    #
    
    # Get leaf certificate of certificate chain
    leaf_cert = None
    leaf_cert_serial = auth.signing_cert_id[1]
    for cert in cert_objs:
        if cert.get_serial_number() == leaf_cert_serial:
            leaf_cert = cert
    
    # Sort certificate chain
    cs_chain = sort_cert_chain(leaf_cert, cert_objs)

    # Extract cert fields for all certs in chain
    for cs_cert in cs_chain:
        cert_info = extract_cert_fields(cs_cert, finfo)
        cert_chains['cs'].append(cert_info)

    if cert_chains['cs']:
        # Check the revocation status of the leaf certificate
        rev_info = cert_revocation_status(cert_chains['cs'], cs_chain, tmp_dir)

        # Add revocation info
        cert_chains['cs'][0]['revoc_info'] = rev_info
        # cert_chains['cs'][0]['revoked'] = True if revoked else False
        # cert_chains['cs'][0]['revoc_reason'] = revoc_reason
        # cert_chains['cs'][0]['revoc_date'] = revoc_time
        # cert_chains['cs'][0]['revoc_error'] = revoc_error

        # Add revocation errors (if any)
        if rev_info['ocsp_error'] or rev_info['crl_error']:
            revoc_error = '|'.join([rev_info['ocsp_error'],
                                    rev_info['crl_error']])
            cert_errors[cert_chains['cs'][0]['der_hash']] = revoc_error
    #
    # Timestamp Certificate chain
    #
    # Get leaf certificate of the timestamp chain
    if auth.has_countersignature:
        ts_leaf_cert = None
        try:
            ts_leaf_cert_serial = auth.counter_sig_cert_id[1]
        except TypeError:
            return cert_chains, cert_errors
        for cert in cert_objs:
            if cert.get_serial_number() == ts_leaf_cert_serial:
                ts_leaf_cert = cert

        # Sort certificate chain
        ts_chain = sort_cert_chain(ts_leaf_cert, cert_objs)

        # Extract cert fields for all certs in chain
        for ts_cert in ts_chain:
            cert_info = extract_cert_fields(ts_cert, finfo)
            cert_chains['ts'].append(cert_info)

    return cert_chains, cert_errors


def cert_revocation_status(cert_chain, cert_chain_objs, tmp_dir):
    '''Checks if a certificate is revoked. It uses first the CRL (if provided)
    and then the OCSP method.'''
    rev_info = {
               'ocsp_revoked': None,
               'ocsp_revoc_time': None,
               'ocsp_revoc_reason': None,
               'ocsp_error': '',
               'crl_revoked': None,
               'crl_revoc_time': None,
               'crl_revoc_reason': None,
               'crl_error': ''}

    lf_cert = cert_chain[0]
    lf_cert_obj = cert_chain_objs[0]

    if not lf_cert['crl_uri'] and not lf_cert['ocsp_uri']:
        return rev_info

    # Check OCSP (if ocsp_uri is included in the certificate)
    if lf_cert['ocsp_uri']:
        rev_info['ocsp_revoked'], rev_info['ocsp_revoc_time'],\
        rev_info['ocsp_revoc_reason'], rev_info['ocsp_error'] =\
            ocsp_revoked(lf_cert['ocsp_uri'], cert_chain,
                         cert_chain_objs, tmp_dir)

    # Check CRL if OCSP did not return anything
    # and crl_uri is included in the certificate
    if lf_cert['crl_uri']:
        rev_info['crl_revoked'], rev_info['crl_revoc_time'],\
        rev_info['crl_revoc_reason'], rev_info['crl_error'] =\
                                crl_revoked(lf_cert['crl_uri'],
                                            lf_cert['serial'],
                                            tmp_dir)
    return rev_info


def dump_certificate_in_pem(fpath, cert):
    '''Receives a filepath and a M2Crypto X509 object and dumps the certificate
    in PEM format in the specific filepath.'''
    with open(fpath, 'w') as fw:
        fw.write(cert.as_pem())


def ocsp_revoked(ocsp_uri, chain_dict, chain_objs, tmp_dir):
  """Checks if the leaf certificate of a chain is revoked using an external
  call to OpenSSL OCSP tool"""
  revoked = None
  revoc_time = None
  revoc_reason = None
  ocsp_error = ''

  # Select Leaf and Issuer certificates
  if len(chain_objs) > 1:
      leaf_cert = chain_objs[0]
      leaf_cert_der_hash = chain_dict[0]['der_hash']
      iss_cert = chain_objs[1]
      iss_cert_der_hash = chain_dict[1]['der_hash']
  elif len(chain_objs) == 1:
      leaf_cert = chain_objs[0]
      leaf_cert_der_hash = chain_dict[0]['der_hash']
      iss_cert = chain_objs[0]
      iss_cert_der_hash = chain_dict[0]['der_hash']

  # Dump certificates to the temporary dir
  leaf_cert_fpath = '{}{}.pem'.format(tmp_dir, leaf_cert_der_hash)
  dump_certificate_in_pem(leaf_cert_fpath, leaf_cert)
  iss_cert_fpath = '{}{}.pem'.format(tmp_dir, iss_cert_der_hash)
  dump_certificate_in_pem(iss_cert_fpath, iss_cert)

  # Make the OCSP request using OpenSSL
  ocsp_res_fname = '{}{}_ocsp_result.txt'.format(tmp_dir, leaf_cert_der_hash)

  with open(ocsp_res_fname, 'w') as ocsp_out:
    if 'globalsign' in ocsp_uri:
      # Use the openssl ocsp -header parameter
      cmd = 'openssl ocsp -no_nonce -issuer {} -cert {} -text'\
            ' -url {} -header \"HOST\" \"ocsp2.globalsign.com\"'.\
                format(iss_cert_fpath, leaf_cert_fpath, ocsp_uri) 
    elif 'startssl' in ocsp_uri:
      # Use the openssl ocsp -header parameter
      cmd = 'openssl ocsp -no_nonce -issuer {} -cert {} -text'\
            ' -url {} -header \"HOST\" \"ocsp.startssl.com\"'.\
                format(iss_cert_fpath, leaf_cert_fpath, ocsp_uri) 
    else:
      cmd = 'openssl ocsp -no_nonce -issuer {} -cert {} -text -url {}'.\
            format(iss_cert_fpath, leaf_cert_fpath, ocsp_uri) 

    ossl = subprocess.Popen(cmd, shell=True, stdout=ocsp_out, stderr=ocsp_out)
    ossl.wait()

  # Parse the result file to extract the OCSP response 
  with open(ocsp_res_fname, 'r') as ocsp_out:
      lines = ocsp_out.readlines()
  lines_clean = list(map(str.strip, lines))
  processed = 0

  for pos,value in enumerate(lines_clean):
    # Spelling Mistake exists on some OCSP responder (e.g., GlogalSign)
    if "Error querying OCSP responder" in value\
      or "Error querying OCSP responsder" in value:
      # We couldn't query the OCSP responder
      # In the next line you see the reason
      try:
        error = lines_clean[pos+1].split("Reason=")[1]
      except IndexError:
        #Could not find the field Reason in the response
        ocsp_error = 'Error querying OCSP reponder: {}.'.format(lines_clean)
      processed = 1
      break
    elif "Responder Error:" in value:
      # We queried the responder and replied with error
      ocsp_error = 'OCSP Responder Error: {}'.\
              format(value.split('Responder Error:')[1]) 
      processed = 1
      break
    elif "Error parsing URL" in value:
      # The OCSP URI had a mistake
      ocsp_error = 'Error parsing OCSP URI: {}'.format(ocsp_uri)
      processed = 1
      break
    elif "Cert Status" in value:
      processed = 1
      # We have an OCSP response
      status = value.split("Cert Status:")[1].strip()
      if status == "revoked":
        revoked = True
        # Revocation time on the next line
        time = lines_clean[pos+1].split("Revocation Time:")[1].strip()
        revoc_time = parse(time).\
                     replace(tzinfo=None).\
                     strftime('%Y-%m-%d %H:%M:%S')
        # Revocation reason may exist on the next line
        if "Revocation Reason:" in lines_clean[pos+2]:
          revoc_reason = lines_clean[pos+2].\
                         split("Revocation Reason:")[1].\
                         split("(")[0].strip()
      elif status == "good":
        revoked =  False
        revoc_time = None
        revoc_reason = None
      elif status == "unknown":
        revoked =  None 
        revoc_time = None
        revoc_reason = None
        ocsp_error = "OCSP cert status unknown."
  if not processed: 
      ocsp_error = ' Could not parse OCSP response: {}'.format(lines_clean)
  return revoked, revoc_time, revoc_reason, ocsp_error


def crl_revoked(crl_uri, cert_sn, tmp_dir):
  '''Checks if the leaf certificate of a chain is revoked using the CRL'''
  revoked = None
  revoc_time = None
  revoc_reason = None
  revoc_error = ''

  # File to store the CRL
  crl_fname = "{}{}".format(tmp_dir, crl_uri.split('/')[-1])

  # Get the CRL list
  try:
      res = requests.get(crl_uri, timeout=2.7, stream=True)
  except requests.exceptions.ConnectionError:
      revoc_error = 'Cannot establish connection to CRL: {}.'.format(crl_uri)
      return revoked, revoc_time, revoc_reason, revoc_error
  except requests.exceptions.InvalidSchema, e:
      revoc_error = 'CRL error: {}.'.format(str(e))
      return revoked, revoc_time, revoc_reason, revoc_error
  except requests.exceptions.Timeout, e:
      revoc_error = 'CRL error: {}.'.format(str(e))
      return revoked, revoc_time, revoc_reason, revoc_error
  except requests.exceptions.ReadTimeoutError, e:
      revoc_error = 'CRL error: {}.'.format(str(e))
      return revoked, revoc_time, revoc_reason, revoc_error

  if res.status_code == 200:
      with open(crl_fname, 'wb') as wf:
            shutil.copyfileobj(res.raw, wf)
  else:
      revoc_error = 'Cannot download CRL: {}. HTTP Code returned: {}.'.\
              format(crl_uri, res.status_code)
      return revoked, revoc_time, revoc_reason, revoc_error

  # Open CRL file
  with open( crl_fname, "r") as crl:
    crl_stream = crl.read()

  # Load CRL file with OpenSSL
  try:
    crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_ASN1, crl_stream)
  except:
    # Try loading as a PEM FILE
    try:
      crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_PEM, crl_stream)
    except:
      revoc_error = "OpenSSL cannot parse CRL list"
      return revoked, revoc_time, revoc_reason, revoc_error

  all_revoked = crl.get_revoked()

  if not all_revoked:
    # Revocation list is empty
    revoked = 0
    revoc_error = "CRL list was empty"
    return revoked, revoc_time, revoc_reason, revoc_error

  for rev_obj in crl.get_revoked():
    sn = rev_obj.get_serial()
    #print "Cert: %s, rev_obj: %s"%(str(cert_sn_hex), sn)
    if sn == cert_sn.upper():
      # Cert is revoked
      revoked = 1
      revoc_time = parse(str(rev_obj.get_rev_date())).\
                   replace(tzinfo=None).\
                   strftime('%Y-%m-%d %H:%M:%S')
      revoc_reason = rev_obj.get_reason()
      break
  else:
    # Certificate was not in the CRL list
    revoked = 0
  return revoked, revoc_time, revoc_reason, revoc_error
