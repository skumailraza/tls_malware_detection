#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
import sys

LOGS_JSON = '../pcap_processing/tls_mal_local.jsons'

def list_diff(li1, li2): 
    li_dif = [i for i in li1 + li2 if i not in li1 or i not in li2] 
    return li_dif 


def get_resumed_conns(ssldmlog):
    resumed_from = {}
    server_session_ids = {}
    server_session_tickets = {}
    fake_resumed_conns = []
    # Do a pass to store the Session IDs/Tickets provided by the servers
    for en in ssldmlog:
        # Fill the cache
        if not en['resumed']:
            # Fill the cache
            if en['s_session_id']:
                server_session_ids[en['s_session_id']] = en
            if en['s_session_ticket']:
                server_session_tickets[en['s_session_ticket']] = en
    for en in ssldmlog:
        if en['resumed']:
            # Map the resumed connection with the initial one
            if en['c_session_id']:
                try:
                    resumed_from[en['conn_uid']] =\
                            server_session_ids[en['c_session_id']]
                except KeyError:
                    fake_resumed_conns.append(en['conn_uid'])
            else:
                try:
                    resumed_from[en['conn_uid']] =\
                            server_session_tickets[en['c_session_ticket']]
                except KeyError:
                    fake_resumed_conns.append(en['conn_uid'])

    return resumed_from, fake_resumed_conns

def main():
    """    """
    sys.stdout.write('sha2\tpcap_md5\tres_conn_id\tfield\torig_value'\
                     '\tresumed_value\tsni\n')
    no_content_conns = 0
    with open(LOGS_JSON) as fr:
        for pos, en in enumerate(fr):
            # if pos and pos % 1000 == 0:
            #     break
            entry = json.loads(en)
            sha2 = entry[0].replace('.pcap', '')
            pcap_md5 = entry[1]
            if not entry[2]:
                continue
            if 'ssl_dm.log' not in entry[2]:
                continue

            # Get the mapping from a resumed connection to the initial one
            # This way you can use the initial conn_uid to extract any desired
            # features that exist only in the full handshake
            resumed_from, fake_resumed_conns =\
                    get_resumed_conns(entry[2]['ssl_dm.log'])

            fields_to_check = [#Client features
                               'c_version', 'c_rec_version', 'c_ciphers',
                               'c_comp_methods', 'c_curves', 'c_point_formats',
                               'c_supported_versions', 'c_alpn_list',
                               'c_extensions',
                               # Server features
                               's_version', 's_record_version', 's_cipher',
                               's_comp_method', 's_extensions', 's_alpn_list'
                               ]

            # Parse Gibran's fields
            for pos, en in enumerate(entry[2]['ssl_dm.log']):
                if en['enc_data_size'] == 0:
                    no_content_conns += 1
                if en['resumed'] and en['conn_uid'] not in fake_resumed_conns:
                    res_conn_id = en['conn_uid']
                    # Check for differences
                    for field in en.keys():
                        if field in fields_to_check:
                            if en[field] != resumed_from[res_conn_id][field]:
                                sys.stdout.write('{}\t{}\t{}\t{}\t{}\t'\
                                                 '{}\t{}\n'.\
                                    format(sha2, pcap_md5, res_conn_id,
                                           field, en[field], 
                                           resumed_from[res_conn_id][field],
                                           en['server_name']))
    #
    sys.stderr.write('[-] # Connections wthout content: {}\n'.\
                     format(no_content_conns))

if __name__ == '__main__':
    main()
