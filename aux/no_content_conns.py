#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
import sys

LOGS_JSON = '../pcap_processing/tls_mal_local.jsons'

def get_resumed_conns(ssldmlog):
    resumed_from = {}
    server_session_ids = {}
    server_session_tickets = {}
    fake_resumed_conns = []
    # Do a pass to store the Session IDs/Tickets provided by the servers
    for en in ssldmlog:
        # Fill the cache
        if not en['resumed']:
            # Fill the cache
            if en['s_session_id']:
                server_session_ids[en['s_session_id']] = en
            if en['s_session_ticket']:
                server_session_tickets[en['s_session_ticket']] = en
    for en in ssldmlog:
        if en['resumed']:
            # Map the resumed connection with the initial one
            if en['c_session_id']:
                try:
                    resumed_from[en['conn_uid']] =\
                            server_session_ids[en['c_session_id']]
                except KeyError:
                    fake_resumed_conns.append(en['conn_uid'])
            else:
                try:
                    resumed_from[en['conn_uid']] =\
                            server_session_tickets[en['c_session_ticket']]
                except KeyError:
                    fake_resumed_conns.append(en['conn_uid'])

    return resumed_from, fake_resumed_conns

def main():
    """    """
    sys.stdout.write('sha2\tpcap_md5\tconn_id\tis_resumed\tlater_resumed'\
                     '\testablished\tsni\n')
    with open(LOGS_JSON) as fr:
        for pos, en in enumerate(fr):
            # if pos and pos % 1000 == 0:
            #     break
            entry = json.loads(en)
            sha2 = entry[0].replace('.pcap', '')
            pcap_md5 = entry[1]
            if not entry[2]:
                continue
            if 'ssl_dm.log' not in entry[2]:
                continue

            # Get the mapping from a resumed connection to the initial one
            # This way you can use the initial conn_uid to extract any desired
            # features that exist only in the full handshake
            res_from, fake_resumed_conns =\
                    get_resumed_conns(entry[2]['ssl_dm.log'])

            later_res_conns = set([i['conn_uid'] for c, i in res_from.items()])

            # Parse Gibran's fields
            for pos, en in enumerate(entry[2]['ssl_dm.log']):
                if en['enc_data_size'] == 0:
                    later_resumed = False
                    if en['conn_uid'] in later_res_conns:
                        later_resumed = True
                    sys.stdout.write('{}\t{}\t{}\t{}\t{}\t{}\t{}\n'.format(
                        sha2, pcap_md5, en['conn_uid'],
                        en['resumed'], later_resumed, en['established'],
                        en['server_name']))


if __name__ == '__main__':
    main()

