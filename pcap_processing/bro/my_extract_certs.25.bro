##! This script is used to extract host certificates seen on the wire to disk
##! after being converted to PEM files.  The certificates will be stored in
##! a single file, one for local certificates and one for remote certificates.
##!
##! .. note::
##!
##!     - It doesn't work well on a cluster because each worker will write its
##!       own certificate files and no duplicate checking is done across the
##!       cluster so each node would log each certificate.
##!

# This is the complete list of dependencies so that it can run barebone mode
@load base/protocols/conn
@load base/protocols/dns
@load base/protocols/ssl
@load base/utils/directions-and-hosts
@load ./dns_cache
@load policy/protocols/ssl/validate-certs
@load policy/protocols/ssl/heartbleed.bro
@load frameworks/files/hash-all-files.bro
# @load misc/dump-events


# This is an internally maintained set to prevent relogging of
# certificates that have already been seen. 
# It is indexed on the md5 of the certificate in DER format
global extracted_certs : set[string] = set() &read_expire=2hr &redef;

# This is an internally maintained set to prevent relogging of
# client cipher suites that have already been seen. 
# It is indexed on the md5 of the client cipher suite
global client_cipher_suites : set[string] = set() &read_expire=2hr &redef;

module SSL;

export {
  # Control if host certificates offered by the defined hosts
  # will be written to the PEM certificates file.
  # Choices are: LOCAL_HOSTS, REMOTE_HOSTS, ALL_HOSTS, NO_HOSTS.
  const extract_certs_pem = ALL_HOSTS &redef;

  redef record Info += {
    # The random value sent by the client. 
    # For version 2 connections, the client challenge is returned.
    c_random: string &default="-";
    # The random value sent by the server. 
    # For version 2 connections, the connection-id is returned.
    s_random: string &default="-";
    # Heartbleed detected
    heartbleed: bool &optional;
    # Set of client extensions
    cextensions : vector of string &redef &default = vector();
    # Set of server extensions
    sextensions : vector of string &redef &default = vector();
    # Number of cipher suites sent by client
    num_client_cipher_suites : count &default = 0;
    # Set of client ciphers
    c_ciphers : vector of string &redef &default = vector();
    # Hash of client ciphers concatenated together
    c_ciphers_hash : string &redef &default="-";
    # Hash of client extensions concatenated together
    c_ext_hash : string &redef &default="-";
    # Hash of server extensions concatenated together
    s_ext_hash : string &redef &default="-";
    # The curves supported by the client.
    #c_curves: vector of string  &log &optional &default=vector("-");
    c_curves: vector of string  &redef &optional &default = vector();
    # supported elliptic curve point formats
    # c_point_formats: vector of string  &log &optional &default=vector("-");
    c_point_formats: vector of string  &redef &optional &default = vector();
    # Server Session id - Session ID delivered to client in a server HELLO msg
    s_session_id : string &redef &default="-";
    # Client Session id - Session ID sent to server in a client HELLO msg
    c_session_id : string &redef &default="-";
    # Session Ticket (RFC 5077) presented by the client in the Client Hello
    c_session_ticket_hash: string &default="-";
    # Session Ticket presented by the server in the Server Hello
    s_session_ticket_hash: string &default="-";
    # A hint from the server about how long the session ticket should be stored by the client.
    session_ticket_lifetime_hint: count &default=0;
    # List of supported TLS versions by the client
    c_supported_versions: vector of string  &redef &optional &default = vector();
    # Certificate Transparency signature by client
    c_ct_signature: string &default="-";
    # List of client supported application protocols
    c_alpn_list: vector of string  &redef &optional &default = vector();
    # List of server supported application protocols
    s_alpn_list: vector of string  &redef &optional &default = vector();
   };
}


# Log files
const conn_log_file = open("ssl_conns.log") &raw_output;
const cert_log_file = open("ssl_certs.log") &raw_output;
const ciphers_log_file = open("ssl_ciphers.log") &raw_output;


# At startup, print log headers 
event bro_init()
  {
  # Register DPD ports
  Analyzer::register_for_ports(Analyzer::ANALYZER_SSL,ssl_ports);

  # Connection log

  local conn_hdr=fmt("#separator \\x09\n#set_separator	,\n#empty_field	(empty)\n#unset_field	-\n#path	ssl_conns\n#open	3019-09-19-14-38-24\n#fields\tts\tconn_uid\tdst_IP\tdst_port\tversion\tcipher\ts_session_id\tc_session_id\tnum_server_certs\tvalidation_error\tvalidation_error_str\tdns_domain\tsni_domain\tnum_client_certs\tnum_c_ciphers\tc_ciphers_hash\tnum_c_ext\tc_ext_hash\tnum_s_ext\ts_ext_hash\tc_ciphers\tc_exts\tc_curves\tc_point_formats\tresumed\tc_session_ticket\ts_session_ticket\tsession_ticket_lifetime_hint\theartbleed_detected\tc_supported_versions\tc_ct_signature\tc_alpn_list\ts_alpn_list\tc_random\ts_random\n#types\ttime\tstring\taddr\tstring\tstring\tstring\tstring\tstring\tcount\tcount\tstring\tstring\tstring\tcount\tcount\tstring\tcount\tstring\tcount\tstring\tstring\tstring\tstring\tstring\tbool\tstring\tstring\tcount\tbool\tstring\tstring\tstring\tstring\tstring\tstring\n");
  print conn_log_file, conn_hdr;

  # Certificate log
  local cert_hdr=fmt("#separator \\x09\n#set_separator	,\n#empty_field	(empty)\n#unset_field	-\n#path	ssl_certs\n#open	3019-09-19-14-38-24\n#fields\tconn_uid\tcert_idx\tDER_hash\tsubject\tissuer\n#types\tstring\tstring\tstring\tstring\tstring\n");
  print cert_log_file, cert_hdr;

  # Cipher log
  local cipher_hdr=fmt("#separator \\x09\n#set_separator	,\n#empty_field	(empty)\n#unset_field	-\n#path	ssl_ciphers\n#open	3019-09-19-14-38-24\n#fields\tclient_ciphers_hash\tclient_ciphers_num\tclient_ciphers\n#types\tstring\tcount\tstring\n");
  print ciphers_log_file, cipher_hdr;
}


# At end, close log files
event bro_done()
  {
  close(conn_log_file); 
  close(cert_log_file); 
  } 


#Process client hello messages
event ssl_client_hello(c: connection, version: count, record_version: count, possible_ts: time, client_random: string, session_id: string, ciphers: index_vec, comp_methods: index_vec) &priority=5
{
  c$ssl$c_random = md5_hash(client_random);
  if (|session_id| > 0 && session_id != /^\x00{32}$/){
      c$ssl$c_session_id = bytestring_to_hexstr(session_id);
  }
  else
  {
      c$ssl$c_session_id = "-";
  }
  #A handle that calculates an MD5 checksum incrementally 
  local handle: opaque of md5 = md5_hash_init();
  for (i in ciphers)
    {
    #Add to the incremental MD5 hash each Cipher (string) supported
    #by the client. It keeps the order of them by default
    md5_hash_update(handle, SSL::cipher_desc[ciphers[i]]);

    # Increase number of cipher suites
    c$ssl$num_client_cipher_suites += 1;
    }

  # Save client cipher hash  
  c$ssl$c_ciphers_hash = md5_hash_finish(handle);

  # Create a vector of strings for storing client ciphers
  for (i in ciphers)
  {
    # local cipher_fmt = fmt("%d", ciphers[i]);
    c$ssl$c_ciphers[i] = fmt("%d", ciphers[i]);
  }
  # If new hash, add to ciphers log file
  if ( ! ( c$ssl$c_ciphers_hash in client_cipher_suites ) )
    {
    add client_cipher_suites[c$ssl$c_ciphers_hash];
    local cipher_fmt = fmt("%s\t%s\t", 
      c$ssl$c_ciphers_hash, c$ssl$num_client_cipher_suites);
    print ciphers_log_file, cipher_fmt;

    for (i in ciphers)
    {
      cipher_fmt = fmt("%s,", SSL::cipher_desc[ciphers[i]]);
      print ciphers_log_file, cipher_fmt; 
    }
    print ciphers_log_file, "\n";
    }

}


event ssl_server_hello(c: connection, version: count, record_version: count, possible_ts: time, server_random: string, session_id: string, cipher: count, comp_method: count) &priority=5 
{
  c$ssl$s_random = md5_hash(server_random);
  if (|session_id| > 0 && session_id != /^\x00{32}$/){
      c$ssl$s_session_id = bytestring_to_hexstr(session_id);
  }
  else
  {
      c$ssl$s_session_id = "-";
  }

}

event ssl_session_ticket_handshake(c: connection, ticket_lifetime_hint: count, ticket: string)
{
    c$ssl$s_session_ticket_hash = md5_hash(ticket);
    c$ssl$session_ticket_lifetime_hint = ticket_lifetime_hint;
}


event ssl_extension_application_layer_protocol_negotiation(c: connection, is_orig: bool, protocols: string_vec)
{
  if (is_orig){
      c$ssl$c_alpn_list = protocols;
  }
  else
  {
      c$ssl$s_alpn_list = protocols;
  }
}


# Process client extensions
event ssl_extension(c: connection, is_orig: bool, code: count, val: string) &priority=5
  {
  if ( ! is_orig )
    #Add server extension to set
    c$ssl$sextensions[|c$ssl$sextensions|] = fmt("%d", code);
  else
    {
    # Set the client session ticket side
    if ( extensions[code] == "SessionTicket TLS")
    {
        c$ssl$c_session_ticket_hash = md5_hash(val);
    }
    # Add client extension to set
    c$ssl$cextensions[|c$ssl$cextensions|] = fmt("%d", code);

    # Store SNI extension in variable
    if ( extensions[code] == "server_name" )
      {
      c$ssl$server_name = sub_bytes(val, 6, |val|);
      }
    }
  }


event ssl_extension_signed_certificate_timestamp(c: connection, is_orig: bool, version: count, logid: string, timestamp: count, signature_and_hashalgorithm: SSL::SignatureAndHashAlgorithm, signature: string)
{
  set_session(c);
  if ( !is_orig )
    return;
  c$ssl$c_ct_signature = signature;
}


event ssl_extension_supported_versions(c: connection, is_orig: bool, versions: index_vec)
{
  set_session(c);
  if ( !is_orig )
    return;
  for (i in versions)
  {
    c$ssl$c_supported_versions[i] = fmt("%d", versions[i]);
  }
}


event ssl_extension_elliptic_curves(c: connection, is_orig: bool, curves: index_vec)
{
  set_session(c);
  if ( !is_orig )
    return;
  for (i in curves)
  {
    c$ssl$c_curves[i] = fmt("%d", curves[i]);
  }
}


event ssl_extension_ec_point_formats(c: connection, is_orig: bool, point_formats: index_vec)
{
  set_session(c);
  if ( !is_orig )
    return;
  for (i in point_formats)
  {
      c$ssl$c_point_formats[i] = fmt("%d", point_formats[i]);
  }
}

# Log the whole information about the SSL conversation for each side of the connection
event connection_state_remove(c: connection)
#event ssl_established(c: connection)
{
  #if ( ! c$ssl?$cert_chain || |c$ssl$cert_chain| == 0 ||
  #     ! c$ssl$cert_chain[0]?$x509 )
  #     return;
  if ( ! addr_matches_host(c$id$resp_h, extract_certs_pem) )
      return;
  
  #
  # Server certificate chain
  #
  # Number of certificates in server chain
  local chain: vector of opaque of x509 = vector();
  if (c?$ssl){
      if (c$ssl?$cert_chain){
          for (idx in c$ssl$cert_chain)
          {
            local cert_hash = c$ssl$cert_chain[idx]$md5;
            local cert = c$ssl$cert_chain[idx]$x509$handle;
            # Update new local chain used for validation
            chain[idx] = c$ssl$cert_chain[idx]$x509$handle;
            # Dump certificate if not seen before
            if ( ! ( cert_hash in extracted_certs ) )
            {
              add extracted_certs[cert_hash];
              local filename = fmt("%s.pem", cert_hash);
              local f_handler = open(filename);
              write_file(f_handler, x509_get_certificate_string(cert, T));
              close(f_handler);
            }
            # Log certificate
            local cert_line=fmt("%s\tS%d\t%s\t%s\t%s\n",
              c$uid, idx, cert_hash, c$ssl$cert_chain[idx]$x509$certificate$subject,
              c$ssl$cert_chain[idx]$x509$certificate$issuer);
            print cert_log_file, cert_line;
          }
      }
      #
      # Process client certificate chain (if exists)
      #
      if (c$ssl?$client_cert_chain)
      {
        for (cl_idx in c$ssl$client_cert_chain)
        {
          local cl_cert_hash = c$ssl$client_cert_chain[cl_idx]$md5;
          local cl_cert = c$ssl$client_cert_chain[cl_idx]$x509$handle;
          # Dump certificate if not seen before
          if ( ! ( cl_cert_hash in extracted_certs ) )
          {
            add extracted_certs[cert_hash];
            local cl_filename = fmt("%s.pem", cl_cert_hash);
            local cl_f_handler = open(cl_filename);
            write_file(cl_f_handler, x509_get_certificate_string(cl_cert, T));
            close(cl_f_handler);
          }
          # Log certificate
          local cl_cert_line=fmt("%s\tC%d\t%s\t%s\t%s\n",
            c$uid, cl_idx, cert_hash, c$ssl$client_cert_chain[cl_idx]$x509$certificate$subject,
            c$ssl$client_cert_chain[cl_idx]$x509$certificate$issuer);
          print cert_log_file, cl_cert_line;
        
        }
      }
      #
      # Validate certificate chain
      local val_status = "-";
      local val_code = -100;
      if (|chain| > 0){
          local val_result = x509_verify(chain, root_certs);
          val_status = val_result$result_string;
          val_code = val_result$result;
      }
      local val_code_str: string;
      if (val_code == -100){
         val_code_str = "-";
      }
      else{
         val_code_str = fmt("%d", val_code);
      }
      # Calculate number of certificates in server chain
      local num_server_certs = 0;
      if (c$ssl?$cert_chain){
          num_server_certs = |c$ssl$cert_chain|;
      }

      # Calculate number of certificates in client chain
      local num_client_certs : count;
      if ( c$ssl?$client_cert_chain )
        num_client_certs = |c$ssl$client_cert_chain|;
      else
        num_client_certs = 0;
      # Check DNS cache
      local domain_name = DNScache::check_dns_cache(c$id$orig_h,c$id$resp_h);

      # Check Server Name Identification
      local sni : string;
      if ( c$ssl?$server_name )
        sni = c$ssl$server_name;
      else
        sni = "-";


      # Calculate the hash of the client extensions 
      local handle : opaque of md5;
      local code_str : string;
      if ( |c$ssl$cextensions| > 0 )
        {
        handle = md5_hash_init();
        for (i in c$ssl$cextensions)
          {
            code_str = fmt("+%s", c$ssl$cextensions[i]);
            md5_hash_update(handle, code_str);
          }
        c$ssl$c_ext_hash = md5_hash_finish(handle);
        }

      # Calculate the hash of the server extensions 
      if ( |c$ssl$sextensions| > 0 )
        {
        handle = md5_hash_init();
        for (i in c$ssl$sextensions)
          {
            code_str = fmt("+%s", c$ssl$sextensions[i]);
            md5_hash_update(handle, code_str);
          }
        c$ssl$s_ext_hash = md5_hash_finish(handle);
        }

      if (|c$ssl$c_ciphers| == 0){
        c$ssl$c_ciphers = vector("-");
      }

      if (|c$ssl$cextensions| == 0){
        c$ssl$cextensions = vector("-");
      }

      if (|c$ssl$c_curves| == 0){
        c$ssl$c_curves = vector("-");
      }

      if (|c$ssl$c_supported_versions| == 0){
        c$ssl$c_supported_versions = vector("-");
      }

      if (|c$ssl$c_alpn_list| == 0){
        c$ssl$c_alpn_list = vector("-");
      }

      if (|c$ssl$s_alpn_list| == 0){
        c$ssl$s_alpn_list = vector("-");
      }

      if (|c$ssl$c_point_formats| == 0){
        c$ssl$c_point_formats = vector("-");
      }

      if (!c$ssl?$version){
          c$ssl$version="-";
      }

      if (!c$ssl?$cipher){
          c$ssl$cipher="-";
      }

      # Log SSL connection
      local conn_line=fmt("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%d\t%s\t%s\t%s\t%s\t%d\t%d\t%s\t%d\t%s\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", 
        c$ssl$ts, c$uid, c$id$resp_h, c$id$resp_p, 
        c$ssl$version, c$ssl$cipher, c$ssl$s_session_id, c$ssl$c_session_id,
        num_server_certs,
        val_code_str, val_status, domain_name, sni, 
        num_client_certs, 
        c$ssl$num_client_cipher_suites, c$ssl$c_ciphers_hash,
        |c$ssl$cextensions|, c$ssl$c_ext_hash, 
        |c$ssl$sextensions|, c$ssl$s_ext_hash,
        join_string_vec(c$ssl$c_ciphers, ","),
        join_string_vec(c$ssl$cextensions, ","),
        join_string_vec(c$ssl$c_curves, ","),
        join_string_vec(c$ssl$c_point_formats, ","),
        c$ssl$resumed,
        c$ssl$c_session_ticket_hash,
        c$ssl$s_session_ticket_hash,
        c$ssl$session_ticket_lifetime_hint,
        c$ssl$heartbleed_detected,
        join_string_vec(c$ssl$c_supported_versions, ","),
        c$ssl$c_ct_signature,
        join_string_vec(c$ssl$c_alpn_list, ","),
        join_string_vec(c$ssl$s_alpn_list, ","),
        c$ssl$c_random, c$ssl$s_random);
      print conn_log_file, conn_line;
  }


}

