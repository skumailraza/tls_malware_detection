##! Extract information from the TLS Application and Handshake Protocols of every TLS Connection

@load base/protocols/conn
@load base/protocols/ssl
@load policy/protocols/ssl/validate-certs.bro
@load policy/protocols/ssl/heartbleed.bro

module SSL;

type Sequence: record {
	pkts: count &default = 0;
	size: count &default = 0;
};

export {
	# Enable capture of encrypted packets
	redef SSL::disable_analyzer_after_detection = F;

	# Number of messages (sequential packets) taken into account for SSL statistics
	const total_messages: count = 3 &redef;
	# Debugging info into file ssl_fpkts.log
	const debug: bool = F &redef;
	# Extract server name
	const save_sn: bool = T &redef;
	# Avoid connections without encrypted packets
	const avoid_empty: bool = F &redef;

	redef record Info += {
		# The protocol version as extracted from the client’s message.
		c_version: string &default="-"; 
		# TLS version given in the record layer of the Client Hello message. 
		c_record_version: string &default="-"; 
		# TLS version given in the record layer of the Server Hello message. 
		s_record_version: string &default="-"; 
		# The protocol version as extracted from the server’s message.
		s_version: string &default="-"; 
		# List of supported client compression methods - Not available in SSLv2, TLSv13
		c_comp_methods: vector of string &default = vector();
		# List of supported TLS versions by the client
		c_supported_versions: vector of string  &redef &optional &default = vector();
		# Certificate Transparency signature by client
		s_ct_signature: string &default="-";
		# List of client supported application protocols
		c_alpn_list: vector of string  &redef &optional &default = vector();
		# List of server supported application protocols
		s_alpn_list: vector of string  &redef &optional &default = vector();
		# supported elliptic curve point formats
		c_point_formats: vector of string  &redef &optional &default = vector();
		# The curves supported by the client.
		c_curves: vector of string  &redef &optional &default = vector();
		# Heartbleed detected
		heartbleed: bool &optional;
		# True if client sent either a session_id or session ticket; 
		c_resumption_support : bool  &default=F;
		# True if server sent either a session_id or session ticket; 
		s_resumption_support : bool &default=F;
		# Server Session id - Session ID delivered to client in a server HELLO msg
		s_session_id : string &redef &default="-";
		# Client Session id - Session ID sent to server in a client HELLO msg
		c_session_id : string &redef &default="-";
		# Session Ticket (RFC 5077) presented by the client in the Client Hello
		c_session_ticket_hash: string &default="-";
		# Session Ticket presented by the server in the Server Hello
		s_session_ticket_hash: string &default="-";
		# A hint from the server about how long the session ticket should be stored by the client.
		s_session_ticket_lifetime: count &default=0;
		# Extensions advertised by the client
		client_extensions: vector of string &default = vector();
		# Cipher suites offered by the client
		client_ciphers: vector of string &default = vector();
		# Number of client certificates
		client_num_certs: count &default = 0;
		# Days of validity of the client certificate
		client_cert_validity: count &default = 0;
		# Self signed client certificate flag
		client_cert_selfsigned: bool &default = F;
		# Result of client certificate validation
		client_cert_validation_status: string &default = "NULL";
		# Number of Subject Alternative Names in client certificate
		client_num_san: count &default = 0;
		# Extensions advertised by the server
		server_extensions: vector of string &default = vector();
		# Cipher suite selected by the server
		server_cipher_num: count &default = 0;
		# Compression method used by the server
		server_comp_method: count &default = 0;
		# Number of server certificates
		server_num_certs: count &default = 0;
		# Days of validity of the server certificate
		server_cert_validity: count &default = 0;
		# Self signed server certificate flag
		server_cert_selfsigned: bool &default = F;
		# Result of server certificate validation
		server_cert_validation_status: string &default = "NULL";
		# Number of Subject Alternative Names in server certificate
		server_num_san: count &default = 0;
		# Number of SSL encrypted packets sent (without handshake)
		enc_sent_pkts: count &default = 0;
		# Number of SSL encrypted packets received (without handshake)
		enc_recv_pkts: count &default = 0;
		# Number of SSL encrypted packets (without handshake)
		enc_num_packets: count &default = 0;
		# Size in bytes of SSL encrypted data (without handshake)
		enc_data_size: count &default = 0;
		# Size in bytes of SSL encrypted sent data (without handshake)
		enc_sent_size: count &default = 0;
		# Size in bytes of SSL encrypted received data (without handshake)
		enc_recv_size: count &default = 0;
		# Duration of SSL encrypted conversation in seconds
		enc_duration: double &default = 0.0;
		# Duration of sent SSL encrypted packets in seconds
		enc_sent_duration: double &default = 0.0;
		# Duration of received SSL encrypted packets in seconds
		enc_recv_duration: double &default = 0.0;
		# Timing of each SSL packet
		enc_timing: double &default = 0.0;
		# Timing control variable
		last_packet: interval &default = 0 usec;
		# Number of consecutively received packets (client sequence)
		c_seq_recv: count &default = 0;
		# Length of the client sequence
		c_seq_length: count &default = 0;
		# Duration of the client sequence
		c_seq_timing: double &default = 0.0;
		# Vector to store all the client sequences
		c_pkt_seq: vector of Sequence &default = vector();
		# The higher number of consecutively received packets (for client)
		c_max_seq: count &default = 0;
		# The higher length of the client sequence
		c_max_length: count &default = 0;
		# The higher duration of the client sequence
		c_max_timing: double &default = 0.0;
		# Number of consecutively received packets (server sequence)
		s_seq_recv: count &default = 0;
		# Length of the server sequence
		s_seq_length: count &default = 0;
		# Duration of the server sequence
		s_seq_timing: double &default = 0.0;
		# Vector to store all the server sequences
		s_pkt_seq: vector of Sequence &default = vector();
		# The higher number of consecutively received packets (for server)
		s_max_seq: count &default = 0;
		# The higher length of the server sequence
		s_max_length: count &default = 0;
		# The higher duration of the server sequence
		s_max_timing: double &default = 0.0;
	};
}

# Log files
const ssl_fpkts_log_file = open("ssl_fpkts.log") &raw_output;
const ssl_dm_log_file = open("ssl_dm.log") &raw_output;

# At startup, print log headers
event bro_init() {
	if (debug) {
		local f_pkts_hdr_str = "#separator \\x09\n#set_separator ,\n#fields\tconn_UID\tis_orig\tcnt_ty\tmsg_ty\tnum_pkts\t";
		f_pkts_hdr_str += "enc_num_pkts\tlength\tduration\ttiming\tc_seq_recv\tc_seq_length\tc_seq_timing\tc_pkt_seq\t";
		f_pkts_hdr_str += "s_seq_recv\ts_seq_length\ts_seq_timing\ts_pkt_seq\n";
		local f_pkts_hdr = fmt(f_pkts_hdr_str);
		print ssl_fpkts_log_file, f_pkts_hdr;
	}

	local dm_hdr_str = "#separator \\x09\n#set_separator\t,\n#empty_field\t(empty)\n#unset_field\t-\n#path\tssl_dm\n#open\t" + strftime("%Y-%m-%d-%H-%M-%S", current_time()) + "\n";
	dm_hdr_str += "#fields\tconn_uid\tc_src_ip\tc_src_port\ts_dst_ip\ts_dst_port\tstart_time\t";
	dm_hdr_str += "s_version\tc_ciphers\tc_extensions\tc_leaf_cert_num_SAN\tc_num_certs\tc_leaf_cert_validity\ts_comp_method\ts_cipher\ts_extensions\t";
	dm_hdr_str += "s_leaf_cert_num_SAN\ts_num_certs\ts_leaf_cert_validity\tserver_name\ts_leaf_cert_validation_status\ts_leaf_cert_self_signed\tresumed\testablished\t";
	dm_hdr_str += "enc_duration\tenc_sent_duration\tenc_recv_duration\tc_max_timing\ts_max_timing\t";
	dm_hdr_str += "enc_data_size\tenc_sent_size\tenc_recv_size\tenc_num_pkts\tenc_sent_pkts\tenc_recv_pkts\t";
	dm_hdr_str += "c_max_seq\tc_max_length\ts_max_seq\ts_max_length\tsent_recv_size_ratio\tsent_recv_pkts_ratio";
	# Fill headers for c_pkt_seq and s_pkt_seq accordingly to the number of sequences
	local i = 0;
	local dm_hdr_str_tmp = "";
	while (i < total_messages) {
		dm_hdr_str += fmt("\tmsg_pkts_c_%d\tmsg_size_c_%d", i, i);
		dm_hdr_str += fmt("\tmsg_pkts_s_%d\tmsg_size_s_%d", i, i);
		dm_hdr_str_tmp += "\tcount\tcount\tcount\tcount";
		++i;
	}
# Add extra
	dm_hdr_str += "\tc_session_id\ts_session_id\tc_session_ticket\ts_session_ticket\ts_session_ticket_lifetime";
	dm_hdr_str += "\ts_heartbleed_detected\tc_curves\tc_point_formats\ts_ct_signature";
	dm_hdr_str += "\tc_alpn_list\ts_alpn_list\tc_supported_versions\tc_version";
	dm_hdr_str += "\tc_record_version\ts_record_version\tc_comp_methods\tc_resumption_support\ts_resumption_support";
	dm_hdr_str_tmp += "\tstring\tstring\tstring\tstring\tcount\tbool\tstring\tstring";
	dm_hdr_str_tmp += "\tstring\tstring\tstring\tstring\tstring\tstring\tstring";
	dm_hdr_str_tmp += "\tstring\tbool\tbool";

	# Add the field types for ssl_dm.log
	local dm_hdr_types = "\n#types\tstring\taddr\tstring\taddr\tstring\ttime";
	dm_hdr_types += "\tstring\tstring\tstring\tcount\tcount\tcount\tcount\tcount\tstring";
	dm_hdr_types += "\tcount\tcount\tcount\tstring\tstring\tbool\tbool\tbool";
	dm_hdr_types += "\tdouble\tdouble\tdouble\tdouble\tdouble";
	dm_hdr_types += "\tcount\tcount\tcount\tcount\tdouble\tdouble";
	dm_hdr_types += "\tcount\tcount\tcount\tcount\tdouble\tdouble";

	dm_hdr_str += dm_hdr_types + dm_hdr_str_tmp;

	print ssl_dm_log_file, fmt(dm_hdr_str + "\n");

	# local filter: Log::Filter = [$name="ssl-dm", $path="ssl_dm_tmp",
	# $include=set("uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p", "start_time",
	# 	 "version", "c_ciphers", "c_extensions", "c_num_SAN", "c_num_certs", "c_validity", "comp_method", "s_cipher", "s_extensions",
	# 	 "s_num_SAN", "s_num_certs", "s_validity", "server_name", "s_validation_status", "s_self-signed", "resumed",
	# 	 "enc_duration", "enc_sent_duration", "enc_recv_duration", "c_max_timing", "s_max_timing",
	# 	 "enc_data_size", "enc_sent_size", "enc_recv_size", "enc_num_pkts", "enc_pkts_sent", "enc_pkts_recv",
	#	 "c_max_seq", "c_max_length", "s_max_seq", "s_max_length", "sent_recv_size_ratio", "sent_recv_pkts_ratio")];
	# Log::add_filter(SSL::LOG, filter);
}

# At end, close log files
event bro_done() {
	close(ssl_fpkts_log_file);
	close(ssl_dm_log_file);
}

# Extract cipher-suites from client hello messages
event ssl_client_hello(c: connection, version: count, record_version: count, possible_ts: time, client_random: string, session_id: string, ciphers: index_vec, comp_methods: index_vec) &priority=10 {
	set_session(c);
	for (i in comp_methods) {
		c$ssl$c_comp_methods[i] = fmt("%d", comp_methods[i]);
	}
	c$ssl$c_record_version = SSL::version_strings[record_version];
	c$ssl$c_version = SSL::version_strings[version];
	for (i in ciphers) {
		c$ssl$client_ciphers[i] = fmt("%d", ciphers[i]);
	}
	if (|session_id| > 0 && session_id != /^\x00{32}$/){
		c$ssl$c_session_id = bytestring_to_hexstr(session_id);
		c$ssl$c_resumption_support = T;
	}
	else
	{
		c$ssl$c_session_id = "-";
	}
}

# Extract selected cipher-suite and compression method from server hello messages
event ssl_server_hello(c: connection, version: count, record_version: count, possible_ts: time, server_random: string, session_id: string, cipher: count, comp_method: count) &priority=10 {
	set_session(c);
	c$ssl$s_record_version = SSL::version_strings[record_version];
	c$ssl$s_version = SSL::version_strings[version];
	c$ssl$server_cipher_num = cipher;
	c$ssl$server_comp_method = comp_method;
	if (|session_id| > 0 && session_id != /^\x00{32}$/){
		c$ssl$s_session_id = bytestring_to_hexstr(session_id);
		c$ssl$s_resumption_support = T;
	}
	else
	{
		c$ssl$s_session_id = "-";
	}
}

event ssl_session_ticket_handshake(c: connection, ticket_lifetime_hint: count, ticket: string) {
	c$ssl$s_session_ticket_hash = md5_hash(ticket);
	c$ssl$s_resumption_support = T;
	c$ssl$s_session_ticket_lifetime = ticket_lifetime_hint;
}

event ssl_extension_elliptic_curves(c: connection, is_orig: bool, curves: index_vec){
	set_session(c);
	if ( !is_orig )
		return;
	for (i in curves){
		c$ssl$c_curves[i] = fmt("%d", curves[i]);
	}
}

event ssl_extension_ec_point_formats(c: connection, is_orig: bool, point_formats: index_vec){
	set_session(c);
	if ( !is_orig )
		return;
	for (i in point_formats){
		c$ssl$c_point_formats[i] = fmt("%d", point_formats[i]);
	}
}

event ssl_extension_signed_certificate_timestamp(c: connection, is_orig: bool, version: count, logid: string, timestamp: count, signature_and_hashalgorithm: SSL::SignatureAndHashAlgorithm, signature: string){
	set_session(c);
	if ( !is_orig )
		return;
	c$ssl$s_ct_signature = signature;
}

event ssl_extension_application_layer_protocol_negotiation(c: connection, is_orig: bool, protocols: string_vec){
	if (is_orig){
		c$ssl$c_alpn_list = protocols;
	}
	else
	{
		c$ssl$s_alpn_list = protocols;
	}
}

event ssl_extension_supported_versions(c: connection, is_orig: bool, versions: index_vec){
	set_session(c);
	if ( !is_orig )
		return;
	for (i in versions){
		c$ssl$c_supported_versions[i] = fmt("%d", versions[i]);
	}
}

# Extract supported extensions from client and server
event ssl_extension (c: connection, is_orig: bool, code: count, val: string) &priority=5 {
	if (is_orig) {
		# Client extensions
		c$ssl$client_extensions[|c$ssl$client_extensions|] = fmt("%d", code);
		if ( extensions[code] == "SessionTicket TLS")
		{
			c$ssl$c_session_ticket_hash = md5_hash(val);
			c$ssl$c_resumption_support = T;
		}
	} else {
		# Server extensions
		c$ssl$server_extensions[|c$ssl$server_extensions|] = fmt("%d", code);
	}
}

#https://www.bro.org/sphinx-git/scripts/base/bif/plugins/Bro_SSL.events.bif.bro.html#id-ssl_handshake_message
# Dump the details of the TLS handshake to a log file
event ssl_handshake_message (c: connection, is_orig: bool, msg_type: count, length: count) &priority=10 {
	# Set the initial interval for the first handshake message [ClientHello = 0x01]
	if (is_orig) {
		if (msg_type == 0x01)
			c$ssl$last_packet = c$ssl$ts - c$start_time;
	} else { # For renegotiation the ClientHello don't start the conn, server sends hello request [HelloRequest = 0x00]
		if (msg_type == 0x00)
			c$ssl$last_packet = c$ssl$ts - c$start_time;
	}

	# Fix the content type for Hanshake protocol, just for debugging
	local content_type = 0x16;
	# Calculate the timing of the encrypted conversation
	c$ssl$enc_timing = interval_to_double(c$duration - c$ssl$last_packet);
	c$ssl$last_packet = c$duration;

	# Full SSL dump when debugging
	if (debug) {
		local fpkt_line = fmt("%s\t%d\t%d\t%d\t%d\t%d\t%d\t%s\t%s\t%d\t%d\t%s\t%s\t%d\t%d\t%s\t%s\n",
			c$uid, |is_orig|, content_type, msg_type, c$orig$num_pkts+c$resp$num_pkts,
			c$ssl$enc_num_packets, length, c$duration, c$ssl$enc_timing,
			c$ssl$c_seq_recv, c$ssl$c_seq_length, c$ssl$c_seq_timing, c$ssl$c_pkt_seq,
			c$ssl$s_seq_recv, c$ssl$s_seq_length, c$ssl$s_seq_timing, c$ssl$s_pkt_seq);
		print ssl_fpkts_log_file, fpkt_line;
	}
}

#https://www.bro.org/sphinx-git/scripts/base/bif/plugins/Bro_SSL.events.bif.bro.html#id-ssl_encrypted_data
# Save the totals (duration, size, number of packets) of the encrypted
# conversation and dump the low level details of it to a log file
event ssl_encrypted_data (c: connection, is_orig: bool, record_version: count, content_type: count, length: count) &priority=1 {
	# Fix msg_type for Handshake-Finished messages for debugging
	local msg_type = content_type == 0x16 ? 0x14 : 0;

	# Calculate the timing of the encrypted conversation
	c$ssl$enc_timing = interval_to_double(c$duration - c$ssl$last_packet);
	c$ssl$last_packet = c$duration;

	# Only calc the stats if Application Data Protocol is used
	# and limit the number of messages (sequences) received in the conversation
	if (content_type == 0x17 && (total_messages == 0 || |c$ssl$c_pkt_seq| < total_messages || |c$ssl$s_pkt_seq| < total_messages)) {
		if (is_orig) { # Generate a sequence of received packets (Client side)
			if (c$ssl$c_seq_recv > 0) { # Do not store empty sequences (i.e. two continuous requests from client)
				c$ssl$c_pkt_seq[|c$ssl$c_pkt_seq|] = Sequence($pkts=c$ssl$c_seq_recv, $size=c$ssl$c_seq_length);
				c$ssl$c_seq_recv = 0;
				c$ssl$c_seq_length = 0;
				c$ssl$c_seq_timing = 0;
			}
			if (|c$ssl$s_pkt_seq| < total_messages) {
				c$ssl$s_seq_recv += 1;
				c$ssl$s_seq_length += length;
				c$ssl$s_seq_timing += c$ssl$enc_timing;
			}
		} else { # Generate a sequence of received packets (Server side)
			if (c$ssl$s_seq_recv > 0) { # Do not store empty sequences
				c$ssl$s_pkt_seq[|c$ssl$s_pkt_seq|] = Sequence($pkts=c$ssl$s_seq_recv, $size=c$ssl$s_seq_length);
				c$ssl$s_seq_recv = 0;
				c$ssl$s_seq_length = 0;
				c$ssl$s_seq_timing = 0;
			}
			if (|c$ssl$c_pkt_seq| < total_messages) {
				c$ssl$c_seq_recv += 1;
				c$ssl$c_seq_length += length;
				c$ssl$c_seq_timing += c$ssl$enc_timing;
			}
		}
		# Limit the stats to include just those packets below the number of sequences received in the conversation
		if (|c$ssl$c_pkt_seq| < total_messages || |c$ssl$s_pkt_seq| < total_messages) {
			# Save the totals for sent
			c$ssl$enc_sent_size += is_orig ? length : 0;
			c$ssl$enc_sent_duration += is_orig ? c$ssl$enc_timing : 0;
			# Save the totals for received
			c$ssl$enc_recv_size += is_orig ? 0 : length;
			c$ssl$enc_recv_duration += is_orig ? 0 : c$ssl$enc_timing;
			# Save the total size of the encrypted conversation
			c$ssl$enc_data_size += length;
			# Calculate the duration of the encrypted conversation
			c$ssl$enc_duration += c$ssl$enc_timing;
			# Calculate the number of encrypted packets in this conversation
			c$ssl$enc_num_packets += 1;
			# Calculate the number of encrypted sent and received packets in this conversation
			c$ssl$enc_sent_pkts += |is_orig|;
			c$ssl$enc_recv_pkts += |!is_orig|;

			# Selecting the maximum sequence, length and timing of received packets (Client side)
			c$ssl$c_max_seq = c$ssl$c_seq_recv > c$ssl$c_max_seq ? c$ssl$c_seq_recv : c$ssl$c_max_seq;
			c$ssl$c_max_length = c$ssl$c_seq_length > c$ssl$c_max_length ? c$ssl$c_seq_length : c$ssl$c_max_length;
			c$ssl$c_max_timing = c$ssl$c_seq_timing > c$ssl$c_max_timing ? c$ssl$c_seq_timing : c$ssl$c_max_timing;
			# Selecting the maximum sequence, length and timing of sent packets (Server side)
			c$ssl$s_max_seq = c$ssl$s_seq_recv > c$ssl$s_max_seq ? c$ssl$s_seq_recv : c$ssl$s_max_seq;
			c$ssl$s_max_length = c$ssl$s_seq_length > c$ssl$s_max_length ? c$ssl$s_seq_length : c$ssl$s_max_length;
			c$ssl$s_max_timing = c$ssl$s_seq_timing > c$ssl$s_max_timing ? c$ssl$s_seq_timing : c$ssl$s_max_timing;
		}
	} else if (|c$ssl$c_pkt_seq| > total_messages && |c$ssl$s_pkt_seq| > total_messages) {
		# Do not log packets outside the limits of total_messages
		return;
	}

	# Dump the packets of the encrypted conversation for debugging
	if (debug) {
		local fpkt_line = fmt("%s\t%d\t%d\t%d\t%d\t%d\t%d\t%s\t%s\t%d\t%d\t%s\t%s\t%d\t%d\t%s\t%s\n",
			c$uid, |is_orig|, content_type, msg_type, c$orig$num_pkts+c$resp$num_pkts,
			c$ssl$enc_num_packets, length, c$duration, c$ssl$enc_timing,
			c$ssl$c_seq_recv, c$ssl$c_seq_length, c$ssl$c_seq_timing, c$ssl$c_pkt_seq,
			c$ssl$s_seq_recv, c$ssl$s_seq_length, c$ssl$s_seq_timing, c$ssl$s_pkt_seq);
		print ssl_fpkts_log_file, fpkt_line;
	}
}

#https://www.bro.org/sphinx-git/scripts/base/bif/plugins/Bro_SSL.events.bif.bro.html#id-ssl_established
# Log the information of the client and server hello messages
event ssl_established (c: connection) {
	# Server cert features
	if (c$ssl?$cert_chain && |c$ssl$cert_chain| > 0 && c$ssl$cert_chain[0]?$x509) {
		c$ssl$server_num_certs = |c$ssl$cert_chain|;
		local validity_raw = c$ssl$cert_chain[0]$x509$certificate$not_valid_after - c$ssl$cert_chain[0]$x509$certificate$not_valid_before;
		c$ssl$server_cert_validity = double_to_count(interval_to_double(validity_raw)/(60*60*24));
		for (cert_s in c$ssl$cert_chain) {
			if (c$ssl$cert_chain[cert_s]$x509?$san) { #using DNS
				c$ssl$server_num_san += c$ssl$cert_chain[cert_s]$x509$san?$dns ? |c$ssl$cert_chain[cert_s]$x509$san$dns| : 0;
			}
		}
		c$ssl$server_cert_validation_status = c$ssl$validation_status;
		c$ssl$server_cert_selfsigned = c$ssl$validation_status == "self signed certificate" ? T : F;
		c$ssl$server_name = c$ssl?$server_name && save_sn ? c$ssl$server_name : "NULL";
	} else {
		c$ssl$server_num_certs = 0;
		c$ssl$server_cert_validity = 0;
		c$ssl$server_cert_validation_status = "NULL";
		c$ssl$server_cert_selfsigned = F; # False if no certificate
		c$ssl$server_name = c$ssl?$server_name && save_sn ? c$ssl$server_name : "NULL";
	}

	# Client cert features
	if (c$ssl?$client_cert_chain && |c$ssl$client_cert_chain| > 0 && c$ssl$client_cert_chain[0]?$x509) {
		c$ssl$client_num_certs = |c$ssl$client_cert_chain|;
		local client_validity_raw = c$ssl$client_cert_chain[0]$x509$certificate$not_valid_after - c$ssl$client_cert_chain[0]$x509$certificate$not_valid_before;
		c$ssl$client_cert_validity = double_to_count(interval_to_double(client_validity_raw)/(60*60*24));
		for (cert_c in c$ssl$client_cert_chain) {
			if (c$ssl$client_cert_chain[cert_c]$x509?$san) { #using DNS
				c$ssl$client_num_san += c$ssl$client_cert_chain[cert_c]$x509$san?$dns ? |c$ssl$client_cert_chain[cert_c]$x509$san$dns| : 0;
			}
		}
	} else {
		c$ssl$client_num_certs = 0;
		c$ssl$client_cert_validity = 0;
	}
}

# Log the whole information about the SSL conversation for each side of the connection
event connection_state_remove(c: connection) {
	if (c?$ssl) {
		if (avoid_empty) {
			if (!c$ssl?$version_num || c$ssl$version_num == 0) { #skipping TLS connections that doesn't have the version
				return;
			}

			if (c$ssl$enc_recv_pkts == 0 || c$ssl$enc_sent_pkts == 0) { # Avoid conversations without data
				return;
			}
		} else {
			c$ssl$version_num = c$ssl?$version_num ? c$ssl$version_num : 0; # Convert the null in case there are no TLS version
		}

		c$ssl$server_name = c$ssl?$server_name && save_sn ? c$ssl$server_name : "NULL";
		local sent_recv_pkts_ratio: double = c$ssl$enc_recv_pkts == 0 ? -1 : to_double(fmt("%s", c$ssl$enc_sent_pkts))/to_double(fmt("%s", c$ssl$enc_recv_pkts));
		#local recv_sent_ratio: double = c$ssl$enc_sent_pkts == 0 ? -1 : c$ssl$enc_recv_pkts/c$ssl$enc_sent_pkts;
		local sent_recv_size_ratio: double = c$ssl$enc_recv_size == 0 ? -1 : to_double(fmt("%s", c$ssl$enc_sent_size))/to_double(fmt("%s", c$ssl$enc_recv_size));
		# Save the last sequence and maximums (Client side)
		if (c$ssl$c_seq_recv > 0 && |c$ssl$c_pkt_seq| < total_messages) {
			c$ssl$c_pkt_seq[|c$ssl$c_pkt_seq|] = Sequence($pkts=c$ssl$c_seq_recv, $size=c$ssl$c_seq_length);
			c$ssl$c_max_seq = c$ssl$c_seq_recv > c$ssl$c_max_seq ? c$ssl$c_seq_recv : c$ssl$c_max_seq;
			c$ssl$c_max_length = c$ssl$c_seq_length > c$ssl$c_max_length ? c$ssl$c_seq_length : c$ssl$c_max_length;
			c$ssl$c_max_timing = c$ssl$c_seq_timing > c$ssl$c_max_timing ? c$ssl$c_seq_timing : c$ssl$c_max_timing;
		}
		# Save the last sequence and maximums (Server side)
		if (c$ssl$s_seq_recv > 0 && |c$ssl$s_pkt_seq| < total_messages) {
			c$ssl$s_pkt_seq[|c$ssl$s_pkt_seq|] = Sequence($pkts=c$ssl$s_seq_recv, $size=c$ssl$s_seq_length);
			c$ssl$s_max_seq = c$ssl$s_seq_recv > c$ssl$s_max_seq ? c$ssl$s_seq_recv : c$ssl$s_max_seq;
			c$ssl$s_max_length = c$ssl$s_seq_length > c$ssl$s_max_length ? c$ssl$s_seq_length : c$ssl$s_max_length;
			c$ssl$s_max_timing = c$ssl$s_seq_timing > c$ssl$s_max_timing ? c$ssl$s_seq_timing : c$ssl$s_max_timing;
		}

		local i = 0;
		local sequences = "";
		while (i < total_messages) {
			# Sequences received by server (client to server)
			sequences += i < |c$ssl$s_pkt_seq| ? fmt("\t%d\t%d", c$ssl$s_pkt_seq[i]$pkts, c$ssl$s_pkt_seq[i]$size) : "\t0\t0";
			# Sequences received by client (server to client)
			sequences += i < |c$ssl$c_pkt_seq| ? fmt("\t%d\t%d", c$ssl$c_pkt_seq[i]$pkts, c$ssl$c_pkt_seq[i]$size) : "\t0\t0";
			++i;
		}

		local dm_line_str = "%s\t%s\t%s\t%s\t%s\t%s\t";
		# High level
		dm_line_str += "%s\t%s\t%s\t";
		dm_line_str += "%d\t%d\t%d\t";
		dm_line_str += "%d\t%d\t%s\t";
		dm_line_str += "%d\t%d\t%d\t";
		dm_line_str += "%s\t%s\t%s\t";
		dm_line_str += "%s\t%s\t";
		# Low level
		dm_line_str += "%f\t%f\t%f\t";
		dm_line_str += "%f\t%f\t";
		dm_line_str += "%d\t%d\t%d\t";
		dm_line_str += "%d\t%d\t%d\t";
		dm_line_str += "%d\t%d\t%d\t%d\t";
		dm_line_str += "%f\t%f";
		dm_line_str += "%s\t%s\t%s\t%s\t%s\t%d\t";
		dm_line_str += "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" + "\n";

	if (|c$ssl$c_supported_versions| == 0){
		c$ssl$c_supported_versions = vector("-");
	}
	if (|c$ssl$s_alpn_list| == 0){
		c$ssl$s_alpn_list = vector("-");
	}
	if (|c$ssl$c_alpn_list| == 0){
		c$ssl$c_alpn_list = vector("-");
	}
		if (|c$ssl$c_point_formats| == 0){
			c$ssl$c_point_formats = vector("-");
		}
		if (|c$ssl$c_curves| == 0){
					c$ssl$c_curves = vector("-");
		}
		if (|c$ssl$client_ciphers| == 0){
			c$ssl$client_ciphers = vector("-");
		}
		if (|c$ssl$client_extensions| == 0){
			c$ssl$client_extensions = vector("-");
		}
		if (|c$ssl$server_extensions| == 0){
			c$ssl$server_extensions = vector("-");
		}
		local dm_line = fmt(dm_line_str,
			# ID values (6)
			c$uid, c$id$orig_h, c$id$orig_p, c$id$resp_h, c$id$resp_p, c$start_time,
			# High level features (16)
			c$ssl$s_version, join_string_vec(c$ssl$client_ciphers, ","),
			join_string_vec(c$ssl$client_extensions,","),
			c$ssl$client_num_san, c$ssl$client_num_certs, c$ssl$client_cert_validity,
			c$ssl$server_comp_method, c$ssl$server_cipher_num,
			join_string_vec(c$ssl$server_extensions, ","),
			c$ssl$server_num_san, c$ssl$server_num_certs, c$ssl$server_cert_validity,
			c$ssl$server_name, c$ssl$server_cert_validation_status, c$ssl$server_cert_selfsigned,
			c$ssl$resumed, c$ssl$established,
			# Low level time features (5)
			c$ssl$enc_duration, c$ssl$enc_sent_duration, c$ssl$enc_recv_duration,
			c$ssl$c_max_timing, c$ssl$s_max_timing,
			# Low level size and pkts features (12)
			c$ssl$enc_data_size, c$ssl$enc_sent_size, c$ssl$enc_recv_size,
			c$ssl$enc_num_packets, c$ssl$enc_sent_pkts, c$ssl$enc_recv_pkts,
			c$ssl$c_max_seq, c$ssl$c_max_length, c$ssl$s_max_seq, c$ssl$s_max_length,
			sent_recv_size_ratio, sent_recv_pkts_ratio,
			# Low level messages (total_messages*2*2); when total_messages=3 there are 12 features here
			sequences, c$ssl$c_session_id, c$ssl$s_session_id,
			c$ssl$c_session_ticket_hash, c$ssl$s_session_ticket_hash,
			c$ssl$s_session_ticket_lifetime, c$ssl$heartbleed_detected,
			join_string_vec(c$ssl$c_curves, ","),
			join_string_vec(c$ssl$c_point_formats, ","), c$ssl$s_ct_signature,
			join_string_vec(c$ssl$c_alpn_list, ","),
			join_string_vec(c$ssl$s_alpn_list, ","), 
			join_string_vec(c$ssl$c_supported_versions, ","),
			c$ssl$c_version, c$ssl$c_record_version, c$ssl$s_record_version,
			join_string_vec(c$ssl$c_comp_methods, ","), c$ssl$c_resumption_support,
			c$ssl$s_resumption_support);
		print ssl_dm_log_file, dm_line;
	}
}
