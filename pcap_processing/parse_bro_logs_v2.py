#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
reload(sys)
sys.setdefaultencoding("utf-8")
import os
import glob
from datetime import datetime
import subprocess as subp
import json
import time
import hashlib

sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(
  os.path.abspath(os.path.dirname(__file__))))))
import argparse
sys.path.insert(1, 'lib')
import progress_bar as pb
from brologparse import parse_log


# Path to the Bro 2.5 executable in your machine
BRO_BIN = "/usr/local/bro_2.6.1/bin/bro"

# Path to the bro script for Bro 2.5 used in parse_bro_logs.py
BRO_SCRIPT_25 = "{}/bro/my_extract_certs.25.bro".format(os.getcwd())

# Path to the Bro http script
BRO_HTTP_SCRIPT = "{}/bro/my_http.bro".format(os.getcwd())

BRO_SSL_STATS_SCRIPT = "{}/bro/my_ssl.bro".format(os.getcwd())

TMP_DIR = 'tmp/'

def guess_hash(h):
    '''Given a hash string, guess the hash type based on the string length'''
    hlen = len(h)
    if hlen == 32:
        return 'md5'
    elif hlen == 40:
        return 'sha1'
    elif hlen == 64:
        return 'sha256'
    else:
        return None


def md5_file(fname):
    ''' Calculates the MD5 hash of a file'''
    hash_md5 = hashlib.md5()
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


def parse_pcap_name(pcap_fname):
  uid = None
  fields = pcap_fname.split('.pcap')[0].split('_')
  fhash = fields[0]
  if len(fields) == 2:
      uid = fields[1]
  # Verify that it's indeed a proper file hash
  fhash_type = guess_hash(fhash)
  if not fhash_type:
      sys.stderr.write("[-] Cannot extract file hash from PCAP: {}\n".\
                       format(pcap_fname))
  return fhash, fhash_type, uid


def run_bro(fpcap, certs_dir):
    ''' '''
    all_log_records = {}
    # Get the absolute path of the PCAP cause will change working directory
    fpcap =  os.path.abspath(fpcap)

   # Get current working directory
    orig_cwd = os.getcwd()

    # Create a unique outdir for this pcap
    outdir = '{}{}_{}'.format(TMP_DIR,
                              os.path.basename(fpcap).split('.')[0],
                              time.time())
    os.mkdir(outdir)
    # Move to the directory that we want to store Bro logs
    os.chdir(outdir)

    # Clean temporary file contents (just in case)
    os.system("rm -f *.log 2> /dev/null")
    os.system("rm -f *.pem 2> /dev/null")

    # Run Bro (2.5) on the pcap file
    cmd = "%s -C %s %s %s -r %s 2> /dev/null" %\
        (BRO_BIN, BRO_SCRIPT_25,
         BRO_HTTP_SCRIPT, BRO_SSL_STATS_SCRIPT, fpcap)
    bro = subp.Popen(cmd, shell=True)
    bro.wait()

    # Check and parse all logs found in the outdir
    logs = glob.glob('*.log')
    for log in logs:
        # This is a log file used internally by our Bro script; Ignore it
        if log == 'dns_cache.log':
            continue

        # When Bro fails our custom logs are created but they are empty
        if not os.path.getsize(log):
            continue

        # Get all records from this log
        records = []
        for entry in parse_log(log):
          records.append(entry._asdict())

        # Store records for this log
        if records:
            all_log_records[log] = records

    # Clean temporary file contents
    os.system("rm -f *.log 2> /dev/null")
    # Store certificates in certs directory
    os.system("mv *.pem {}/ 2> /dev/null".format(certs_dir))

    # Go back to original working directory
    os.chdir(orig_cwd)
    # Remove unique directory created.
    os.system("rm -r {} 2> /dev/null".format(outdir))
    return all_log_records


def pprint_dict(dic):
    '''Pretty prints a dictionary'''
    import pprint
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(dic)


def main(args):
    """ """
    # Parse PCAPs to skip
    to_skip_md5 = []
    if args.skip:
        with open(args.skip, 'r') as fr:
            for pos, line in enumerate(fr):
                fpcap_md5 = json.loads(line.strip('\n'))[1]
                to_skip_md5.append(fpcap_md5)

    # Prepare list of pcap files to be processed
    if args.dir:
      pcap_files = glob.glob(args.dir + '/*.pcap')
    elif args.pcap:
      pcap_files = [args.pcap]
    total_pcaps_cnt = len(pcap_files)


    if not os.path.isdir(TMP_DIR):
        os.mkdir(TMP_DIR)

    if not os.path.isdir(args.dcerts):
        os.mkdir(args.dcerts)

    certs_dir = os.path.abspath(args.dcerts)

    # Main loop to process each pcap file
    pb.update_progress_bar(0, total_pcaps_cnt)
    with open(args.ofile, 'a') as fw:
        for pos, pcap_file in enumerate(pcap_files):
          if pos and pos % 50 == 0:
              pb.update_progress_bar(pos, total_pcaps_cnt)

          pcap_fname = os.path.basename(pcap_file)
          # Get pcap hash from file name, if proceeds
          fhash, fhash_type, run_id = parse_pcap_name(pcap_fname)
          pcap_md5 = md5_file(pcap_file)
          if pcap_md5 in to_skip_md5:
              sys.stderr.write("[+] Skipping file: {}\n".format(pcap_fname))
              continue

          sys.stderr.write("[+] Processing file: {}\n".format(pcap_fname))

          try:
              log_entries = run_bro(pcap_file, certs_dir)
              fw.write('{}\n'.format(json.dumps([pcap_fname, pcap_md5,
                                                 log_entries])))
          except Exception as e:
              sys.stderr.write('\t[-] Error: {}\n'.format(repr(e)))
    pb.update_progress_bar(pos, total_pcaps_cnt)


def validate_config(args):
    if not args.dir and not args.pcap:
        sys.stderr.write('[+] Error: Provide either the --dir or'\
                         ' --pcap parameter.\n')
        exit(1)
    if args.dir and not os.path.exists(args.dir):
        sys.stderr.write('[+] Error: Directory with pcaps does not exist.\n')
        exit(1)
    if args.pcap and not os.path.exists(args.pcap):
        sys.stderr.write('[+] Error: PCAP provided does not exist.\n')
        exit(1)


if __name__ == '__main__':
    # Parse configuration file
    # config = pconf.ProcessingConfig()

    # Process parameters
    argparser = argparse.ArgumentParser(prog='parse_bro_logs',
                      description=\
          '''Parse a single pcap or a dir with pcaps from the farm, run
          bro and insert them into a database'''.replace('\n', ' '))
    argparser.add_argument('--dir', help='dir with pcaps')
    argparser.add_argument('--ofile', help='file to store results',
                           required=True)
    argparser.add_argument('--dcerts', help='dir to store certificates',
                           required=True)
    argparser.add_argument('--pcap', help='pcap to process')
    argparser.add_argument('--norun',
                           help='Flag to use if no run info is available. '\
                                'Run ids generated automatically.',
                           action='store_true', default=False)
    argparser.add_argument('--skip',
                           help='File with already processed pcaps')
    args = argparser.parse_args()
    validate_config(args)
    main(args)
