from datetime import datetime
# from ipaddress import ip_address
from collections import namedtuple


def _bro_types_mapping(separator_set):
    """Returns a mapping from bro data types to python data 
       types partly based on separator_set char"""

    return {
        "time": lambda ts: datetime.fromtimestamp(float(ts)).\
                                    strftime('%Y-%m-%d %H:%M:%S:%f'),
        "string": str,
        # "addr": ip_address,
        "addr": str,
        "port": int,
        "count": int,
        "bool": lambda value: True if value == "T" else\
                              False if value == "F" else None,
        "enum": str,
        "double": float,
        "interval": float,
        "set[string]": lambda string_set: \
            [str(set_item) for set_item in string_set.split(separator_set)],
        "set[addr]": lambda addr_set: \
            [str(set_item) for set_item in addr_set.split(separator_set)],
        "set[enum]": lambda enum_set: \
            [str(set_item) for set_item in enum_set.split(separator_set)],
        "set[interval]": lambda interv_set: \
            [float(set_item) for set_item in interv_set.split(separator_set)],
        "set[count]": lambda count_set: \
            [int(set_item) for set_item in count_set.split(separator_set)],
        "vector[string]": lambda string_vector: \
            [str(vec_item) for vec_item in string_vector.\
                                           replace('[', '').\
                                           replace(']', '').\
                                           split(separator_set)],
        "vector[addr]": lambda addr_vector: \
            [str(vec_item) for vec_item in addr_vector.
                                           replace('[', '').\
                                           replace(']', '').\
                                           split(separator_set)],
        "vector[enum]": lambda enum_vector: \
            [str(vec_item) for vec_item in enum_vector.
                                           replace('[', '').\
                                           replace(']', '').\
                                           split(separator_set)],
        "vector[interval]": lambda interv_vector: \
          [float(vec_item) for vec_item in interv_vector.
                                           replace('[', '').\
                                           replace(']', '').\
                                           split(separator_set)],
        "vector[count]": lambda count_vector: \
            [int(vec_item) for vec_item in count_vector.\
                                           replace('[', '').\
                                           replace(']', '').\
                                           split(separator_set)],
    }


def parse_log(file_path):
    """Yields a dynamically build log entry nametuple 
       from a bro formatted log file path"""

    with open(file_path, "r") as f:
        # Read log file head
        separator = f.readline().rstrip("\n").split(" ")[1].\
                    encode('raw_unicode_escape').decode('unicode_escape')
        separator_set = f.readline().rstrip("\n").split(separator)[1]
        empty_field = f.readline().rstrip("\n").split(separator)[1]
        unset_field = f.readline().rstrip("\n").split(separator)[1]
        path = f.readline().rstrip("\n").split(separator)[1]
        open_time = f.readline().rstrip("\n").split(separator)[1]
        # replace dots in field names with underscores
        fields = [field.replace(".", "_") for field in f.readline().\
                 rstrip("\n").lstrip("#").split(separator)[1:]]
        types = f.readline().rstrip("\n").lstrip("#").split(separator)[1:]

        # Mapping from bro data types to python data types
        bro_types = _bro_types_mapping(separator_set)

        # Change field name if it's "from"
        # Cannot use "from" as type and field names in namedtuple
        fields = ['froms' if x == 'from' else x for x in fields]
        Entry = namedtuple("%sEntry" % path.title(), fields)

        for line in f:
            if line.startswith("#"):
                continue
            if not line.strip():
                continue
            entry_fields = list()
            for index, field in enumerate(line.rstrip("\n").split(separator)):
                if field != empty_field and field != unset_field:
                    entry_fields.append(bro_types[types[index]](field))
                else:
                    # Use None if field is empty or unset
                    entry_fields.append(None)

            if len(entry_fields):
                yield Entry(*entry_fields)
